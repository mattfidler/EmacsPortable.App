#+title: EmacsPortable.App Startup
#+AUTHOR: Matthew L. Fidler
#+PROPERTY: tangle start.el
* Start EmacsPortable.App Startup timers
This creates a timer to figure out how much time it takes to load EmacsPortable.App
#+BEGIN_SRC emacs-lisp
  (setq debug-on-error t)
  (eval-when-compile
    (require 'cl)) 
  (defconst EmacsPortable-load-time-start (float-time))
  (defvar EmacsPortable-last-time EmacsPortable-load-time-start)
  (defun ep-m (txt)
    "*Emacs Portable Time"
    (message "[EmacsPortable] %s loaded in %1f seconds, %1f seconds elapsed"
             txt
             (- (float-time) EmacsPortable-last-time)
             (- (float-time) EmacsPortable-load-time-start))
    
    (when (and nil (eq system-type 'windows-nt))
      (with-temp-file (concat (getenv "TEMP") "/runningep.flg")
        (insert "Loaded ")
        (insert txt)))
    (setq EmacsPortable-last-time (float-time)))
#+END_SRC
* Set Font
#+BEGIN_SRC emacs-lisp
  (when (getenv "EPSTART")
    (setenv "EPSTART" (replace-regexp-in-string (format "%s$" (char-to-string 13)) "" (getenv "EPSTART")))
    (setenv "EPSTARTDIR" (replace-regexp-in-string (format "%s$" (char-to-string 13)) "" (getenv "EPSTARTDIR"))))
  
  (let ((epi (expand-file-name (if (getenv "EPDATA")
                                   (concat (getenv "EPDATA") "/ini/EmacsPortableApp.ini")
                                 "../Data/ini/EmacsPortableApp.ini") (getenv "EPOTHER")))
        font-name font-size)
    (cond
     ((and (getenv "EPOTHER")
           (if (not (file-exists-p epi)) nil
             (with-temp-buffer
               (insert-file-contents epi)
               (goto-char (point-min))
               (when (re-search-forward "^[ \t]*[fF]ont[ \t]*=[ \t]*\\(.*\\)[ \t]*$" nil t)
                 (setq font-name (match-string 1)))
               (goto-char (point-min))
               (when (re-search-forward "^[ \t]*[Ff]ont[Ss]ize[ \t]*=[ \t]*\\(.*\\)[ \t]*$")
                 (setq font-size (match-string 1)))
               (message "%s,%s" font-name font-size))
             (if (or (not font-name) (not (and (fboundp 'find-font)
                                               (find-font (font-spec :name font-name))))) nil
               (condition-case err
                   (progn
                     (set-face-attribute 'default nil :font (format "%s-%s" font-name
                                                                    (or font-size "12")))
                     t)
                 (error
                  (message "Error setting font %s" (error-message-string err))
                  nil))))))
     ((and (fboundp 'find-font) (find-font (font-spec :name "Anonymous Pro")))
      (set-face-attribute 'default nil :font (format "Anonymous Pro-%s" (or font-size "12"))))
     ((and (fboundp 'find-font) (find-font (font-spec :name "Inconsolata")))
      (set-face-attribute 'default nil :font (format "Inconsolata-%s" (or font-size "12"))))
     ((and (fboundp 'find-font) (find-font (font-spec :name "Consolas")))
      (set-face-attribute 'default nil :font (format "Consolas-%s" (or font-size "12"))))
     ((and (fboundp 'find-font) (find-font (font-spec :name "Monaco")))
      (set-face-attribute 'default nil :font (format "Monaco-%s" (or font-size "15"))))
     ((and (fboundp 'find-font) (find-font (font-spec :name "DejaVu Sans Mono")))
      (set-face-attribute 'default nil :font (format "DejaVu Sans Mono-%s" (or font-size "12"))))
     ((and (fboundp 'find-font) (find-font (font-spec :name "Droid Sans Mono")))
      (set-face-attribute 'default nil :font (format "Droid Sans Mono-%s" (or font-size "12"))))
     ((and (fboundp 'find-font) (find-font (font-spec :name "Andale Mono")))
      (set-face-attribute 'default nil :font (format "Andale Mono-%s" (or font-size "15"))))
     ((and (fboundp 'find-font) (find-font (font-spec :name "Monofur")))
      (set-face-attribute 'default nil :font (format "Monofur-%s" (or font-size "15"))))
     ((and (fboundp 'find-font) (find-font (font-spec :name "Proggy Clean")))
      (set-face-attribute 'default nil :font (format "Proggy Clean-%s" (or font-size "15"))))
     ((and (fboundp 'find-font) (find-font (font-spec :name "Courier")))
      (set-face-attribute 'default nil :font (format "Courier-%s" (or font-size "15"))))))
  
#+END_SRC

* Increase defaults
Increase default =max-lisp-eval-depth=
#+BEGIN_SRC emacs-lisp
(setq max-lisp-eval-depth 15000)
(setq max-specpdl-size 15000)
#+END_SRC

* Get the major and minor versions of emacs
To start the pseudo-server appropriately, we need the major and minor
emacs-version strings.
#+BEGIN_SRC emacs-lisp
  
  ;; Need to have Major and minor version 23.3 for example.
  (defvar emacs-ver (getenv "EMACSVER"))
#+END_SRC
* Set EmacsPortable.App variables
This sets the variables for EmacsPortable.App

#+BEGIN_SRC emacs-lisp
  (defvar ep-server nil
    "Defines if pseudo daemon is running")
  
  (ep-m "Required settings")
  
  
  (defvar usb-drive-letter (if (getenv "EPUSB")
                               (getenv "EPUSB")
                             (substring data-directory 0 3)))
  
  (defvar usb-site-lisp-dir (or (and (getenv "EPOTHER")
                                     (expand-file-name (getenv "EPOTHER")))
                                (expand-file-name "Other" usb-app-dir)))
  (defun ep-set-font ()
    (when (getenv "EPFONT")
      (set-frame-font (getenv "EPFONT"))
      (set-default-font (getenv "EPFONT"))))
  
  (message "Drive:%s\nApp:%s\nLisp:%s\nData:%s" usb-drive-letter
           usb-app-dir
           usb-site-lisp-dir
           data-directory)
  
#+END_SRC
* Paths and load-path
** Recent Files
*** Setup Path Aliases 
:PROPERTIES:
:ID: bb44757d-6018-438b-88f9-eb00f6ae0c42
:END:
To use My dropbox, My documents needs to be set through the
EmacsPortableApp.exe launcher.
#+begin_src emacs-lisp
  ;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; Emacs Portable USB drive can be coded usb:/ or ~usb/
  ;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (setq ep-start-dirs nil)
  (setq ep-start-reg "^~~~~~~~~~~$")
  ;; On windows convert ~/Dropbox to %MY Documents% dropbox
  
  (defcustom EmacsPortable-aliases nil
    "Emacs Portable custom aliaess.  For example you my wish to have ~/org/ be aliased to ~org/ Directory Alias=org and Actual Directory=~/org/"
    :type '(alist :key-type (string :tag "Directory Alias") :value-type (directory :tag "Actual Directory"))
    :group 'EmacsPortable)
  
  (defun ep-usb-convert-file-name (name)
    "Converts a usb filename to a regular file-name"
    (save-match-data
      (let ((ret name)
            (case-fold-search t))
        (when (string-match "^\\(usb:\\|~usb\\)[/\\\\]" ret)
          (setq ret (replace-match usb-drive-letter t t ret)))
        
        (if (and (string-match ep-start-reg ret)
                 (assoc (match-string 1 ret) ep-start-dirs))
            (setq ret (replace-match (concat (cdr (assoc (match-string 1 ret) ep-start-dirs)) "/") t t ret))
          
          (when (and (eq system-type 'windows-nt)
                     (getenv "TEMP")
                     (file-readable-p (getenv "TEMP"))
                     (string-match "^/tmp/" ret))
            (setq ret (replace-match (concat (expand-file-name (getenv "TEMP")) "/") t t ret)))
          (cond
           ((and (eq system-type 'windows-nt) (string-match "~/[Dd]ropbox" ret)
                 (getenv "MYDOC")
                 (file-readable-p (concat (getenv "MYDOC") "\\My Dropbox\\")))
            (setq ret (replace-match (concat (getenv "MYDOC") "\\My Dropbox\\") t t ret)))
           (t ret)))
        (while (string-match "//+" ret)
          (setq ret (replace-match "/" t t ret)))
        (symbol-value 'ret))))
  
  ;; Modified from cygwin-mount.
  (defun ep-usb-file-name-handler (operation name &rest args)
    "Run OPERATION on usb NAME with ARGS.
    
    Map USB name to the dos-type [A-Za-z]:/ and call OPERATION with
    the remapped file-name\(s).  NAME must have the format that looks
    like \"^usb:/\" OR \"^~usb/\"
    
    Also map default dropbox location of ~/Dropbox to
    %MYDOCUMENTS%/My Dropbox under windows.
    
    "
    (ep-usb-real-file-name-handler
     operation
     (cons (ep-usb-convert-file-name name)
           (if (stringp (car args))
               (cons (ep-usb-convert-file-name (car args))
                     (cdr args))
             args))))
  
  (defun ep-usb-real-file-name-handler (operation args)
    "Run OPERATION with ARGS."
    (let ((inhibit-file-name-handlers
           (append '(ep-usb-file-name-handler)
                   (and (eq inhibit-file-name-operation operation)
                        inhibit-file-name-handlers)))
          (inhibit-file-name-operation operation))
      (apply operation args)))
  
  (defun ep-rebuild-aliases ()
    "A function to rebuild the Emacs Portable aliases.  Should be loaded after package, el-get, and yasnippet."
    (interactive)
    (setq ep-start-dirs
          `(("ep" . ,(expand-file-name (concat usb-app-dir "../")))
            ("site-lisp" . ,(expand-file-name (concat usb-app-dir "site-lisp/")))
            ("app" . ,(expand-file-name usb-app-dir))
            ("data" . ,(expand-file-name (expand-file-name (or (getenv "EPDATA")
                                                               (concat usb-app-dir "../Data")))))
            ("nsi" . ,(expand-file-name (expand-file-name (concat usb-app-dir "../Other/source/nsi/"))))
            ("ahk" . ,(expand-file-name (expand-file-name (concat usb-app-dir "../Other/source/ahk/"))))
            ("other" . ,(expand-file-name (expand-file-name (concat usb-app-dir "../Other/"))))
            ("start" . ,(expand-file-name (expand-file-name (concat usb-app-dir "../Data/start/"))))
            ("ini" . ,(expand-file-name (expand-file-name (if (getenv "EPDATA")
                                                              (concat (getenv "EPDATA") "/ini/")
                                                            (concat usb-app-dir "../Data/ini/")))))
            ("src" . ,(expand-file-name (expand-file-name (if (getenv "EPDATA")
                                                              (concat (getenv "EPDATA") "/src/")
                                                            (concat usb-app-dir "../Data/src/")))))
            ,@(mapcar
               (lambda(x)
                 `(,(replace-regexp-in-string "^~*\\(.*?\\)[/\\]*$" "\\1" (format "%s" (car x)))
                   . ,(if (not (string-match "^:" (if (listp (cdr x))
                                                      (car (cdr x))
                                                    (cdr x))))
                          (expand-file-name (if (listp (cdr x))
                                                (car (cdr x))
                                              (cdr x)))
                        (if (listp (cdr x))
                            (car (cdr x))
                          (cdr x)))))
               EmacsPortable-aliases)
            ,@(mapcar
               (lambda(x)
                 `(,(format "%s"
                            (if (string-match "^\\(.*?\\)[0-9_.-]*$" x)
                                (match-string 1 x) x)) .
                                ,(if (not (string-match (regexp-opt '("user" "system" "shared") 'paren) x))
                                     (format "%s/"
                                             (expand-file-name x (concat usb-app-dir "../Data/start")))
                                   (format "%s/"
                                           (expand-file-name x (if (getenv "EPDATA")
                                                                   (concat (getenv "EPDATA") "/start")
                                                                 (concat usb-app-dir "../Data/start")))))))
               (remove-if
                (lambda(x)
                  (or (not (file-directory-p (expand-file-name x (concat usb-app-dir "../Data/start"))))
                      (string-match (format "^%s$"
                                            (regexp-opt '("." "..") 'paren)) x)))
                (directory-files (expand-file-name (concat usb-app-dir "../Data/start")))))))
    
    (when (and (getenv "OHOME") (not (string= "" (getenv "OHOME"))) (file-exists-p (getenv "OHOME")))
      (add-to-list 'ep-start-dirs `("h" . ,(expand-file-name (getenv "OHOME")))))
    
    (when (getenv "MYDOC")
      (add-to-list 'ep-start-dirs `("mydoc" . ,(expand-file-name (getenv "MYDOC")))))
    
    (when (file-exists-p (concat usb-drive-letter "PortableApps"))
      (add-to-list 'ep-start-dirs `("pa" . ,(expand-file-name (concat usb-drive-letter "PortableApps")))))
    
    (if (file-exists-p (concat usb-drive-letter "Documents/"))
        (add-to-list 'ep-start-dirs `("doc" . ,(expand-file-name (concat usb-drive-letter "Documents"))))
      (when (file-exists-p (concat usb-drive-letter "LiberKey/MyDocuments"))
        (add-to-list 'ep-start-dirs `("doc" . ,(expand-file-name (concat usb-drive-letter "LiberKey/MyDocuments"))))))
    
    (when (and (boundp 'custom-theme-directory)
               (boundp 'user-emacs-directory)
               (not (string= (expand-file-name user-emacs-directory)
                             (expand-file-name custom-theme-directory)))
               (file-exists-p custom-theme-directory))
      
      (add-to-list 'ep-start-dirs `("themes" . ,custom-theme-directory))
      (add-to-list 'ep-start-dirs `("theme" . ,custom-theme-directory)))
    
    (when (and (boundp 'package-user-dir) (file-exists-p package-user-dir))
      (add-to-list 'ep-start-dirs `("elpa" . ,package-user-dir)))
    
    (when (and (boundp 'el-get-dir) (file-exists-p el-get-dir))
      (add-to-list 'ep-start-dirs `("el-get" . ,el-get-dir)))
    
    (when (boundp 'yas/snippet-dirs)
      (let ((snips (if (listp yas/snippet-dirs)
                       (nth 0 yas/snippet-dirs)
                     yas/snippet-dirs)))
        (when (file-exists-p snips)
          (add-to-list 'ep-start-dirs `("snips" . ,snips))
          (add-to-list 'ep-start-dirs `("snip" . ,snips))
          (add-to-list 'ep-start-dirs `("snippets" . ,snips))
          (add-to-list 'ep-start-dirs `("snippet" . ,snips)))))
    
    (mapc
     (lambda(x)
       (unless (assoc (if (string-match "^\\(.*?\\)[0-9_.-]*$" x)
                          (match-string 1 x) x) ep-start-dirs)
         (add-to-list 'ep-start-dirs
                      `(,(if (string-match "^\\(.*?\\)[0-9_.-]*$" x)
                             (match-string 1 x) x) .
                             ,(expand-file-name x "~/.emacs.d")))))
     (remove-if
      (lambda(x)
        (or (string-match (format "^%s$"
                                  (regexp-opt
                                   '("eshell"
                                     "url"
                                     "var"
                                     "."
                                     ".." ) t)) x)
            (not (file-directory-p (expand-file-name x "~/.emacs.d")))))
      (directory-files (expand-file-name "~/.emacs.d"))))
    
    (setq ep-start-reg
          (format "^~%s[/\\\\]"
                  (regexp-opt
                   (mapcar
                    (lambda(x)
                      (nth 0 x))
                    ep-start-dirs) 'paren)))
    ;; Make abbreviate choose ~usb so that when saving recent files, this
    ;; is also saved.
    (setq directory-abbrev-alist
          `((,(concat "\\`"
                      (expand-file-name (getenv "HOME"))) . "~")
            (,(concat "\\`" usb-drive-letter) . "~usb/")
            ,@(mapcar (lambda(x) `(,(concat "\\`" (regexp-quote (replace-regexp-in-string "[/]*$" "/" (cdr x)))) . ,(concat "~" (car x) "/"))) ep-start-dirs)
            (,(if (and (eq system-type 'windows-nt)
                       (getenv "MYDOC")
                       (file-readable-p (concat (getenv "MYDOC") "\\My Dropbox")))
                  (concat "\\`" (expand-file-name (concat (getenv "MYDOC") "\\My Dropbox")))
                "\\`~/Dropbox/") . "~/Dropbox/")))
  
    (when (eq system-type 'windows-nt)
      (when (and (getenv "TEMP")
                       (file-readable-p (getenv "TEMP")))
        (add-to-list 'directory-abbrev-alist
                     `(,(replace-regexp-in-string "[/]*$" "/" (expand-file-name (getenv "TEMP"))) . "/tmp/"))))
    
    (setq directory-abbrev-alist 
          (sort directory-abbrev-alist 
                '(lambda(x y) 
                   (> (length (car x)) (length (car y))))))
    (let* ((lst `("~usb/"
                  "usb:/"
                  "~/Dropbox"
                  "~/dropbox"
                  ,@(if (and (eq system-type 'windows-nt)
                             (getenv "TEMP")
                             (file-readable-p (getenv "TEMP")))
                        '("/tmp/")
                      nil)
                  ,@(mapcar (lambda(x)
                              (format "~%s/" (nth 0 x)))
                            ep-start-dirs)
                  ))
           (reg (concat "^"
                        (regexp-opt (append lst
                                            (mapcar (lambda(x)
                                                      (upcase x))
                                                    lst)) 't))))
      (setq file-name-handler-alist
            (remove-if (lambda(x) (eq (cdr x) 'ep-usb-file-name-handler)) file-name-handler-alist))
      (setq file-name-handler-alist
            (cons `(,reg . ep-usb-file-name-handler)
                  file-name-handler-alist))
      (when nil
        (mapc (lambda(test)
                (message "%s\t%s\t%s\t%s\t%s" test
                         (expand-file-name test) (abbreviate-file-name (expand-file-name test))
                         (expand-file-name (concat test "dummy")) (abbreviate-file-name (concat (expand-file-name test) "dummy"))))
              lst)))
    nil)
  (ep-rebuild-aliases)
  (eval-after-load 'yasnippet (ep-rebuild-aliases))
  (eval-after-load 'el-get (ep-rebuild-aliases))
  (eval-after-load 'package (ep-rebuild-aliases))
  (add-hook 'after-init-hook 'ep-rebuild-aliases)
#+end_src
*** Recent Files
Recent files are saved to the =Other/saves/= directory.  Additionally,
the saves are based on the computer name so that system idiosyncrasies
like mac vs pc file names do not affect the loading of files, and the
files are saved per computer. 

This also attempts to speed up the recent files cleanup list by
[[http://stackoverflow.com/questions/2068697/emacs-is-slow-opening-recent-files][ignoring remote computer entries]]
:PROPERTIES:
:ID: e0e982b9-0651-4505-906c-ecb4c71d1a84
:END:
#+begin_src emacs-lisp
  (defgroup EmacsPortable nil
    "EmacsPortable Customization Group"
    :group 'emacs)
  
  (defcustom EmacsPortable-start-recentf 't
    "* Enables Recent Files starting"
    :type 'boolean
    :group 'EmacsPortable)
  
  (when EmacsPortable-start-recentf
    (condition-case err
        (progn
          (setq recentf-keep '(file-remote-p file-readable-p))
          (setq recentf-auto-cleanup 'mode)
          (setq recentf-max-menu-items 20)
          (setq recentf-max-saved-items 1000)
          (setq recentf-save-file
                (concat (if (getenv "EPDATA")
                            (concat (getenv "EPDATA") "/saves/recent-files-")
                          (concat usb-site-lisp-dir "../Data/saves/recent-files-")) system-name))
          (require 'recentf)
          (setq recentf-menu-filter 'recentf-arrange-by-mode)
          (setq recentf-filename-handlers (quote (abbreviate-file-name)))
          ;; recentf-expand-file-name
          (recentf-mode 1))
      (error nil)))
  (ep-m "Recentf")
  
#+end_src

* Fancy Splash-screen to show EmacsPortable.app instead of Emacs
:PROPERTIES:
:ID: cb3ae3d6-4087-4d9d-bb6e-0bc6bb8012ff
:END:
#+begin_src emacs-lisp
  (defun fancy-splash-head ()
    "Insert the head part of the splash screen into the current buffer."
    ;; Redefined this
    (let* ((image-file (cond ((stringp fancy-splash-image)
                              fancy-splash-image)
                             ((display-color-p)
                              (concat usb-app-dir "/img/"
                                      (cond 
                                       ((image-type-available-p 'png)
                                        "emacsportable.png")
                                       ((image-type-available-p 'jpeg)
                                        "emacsportable.jpg")
                                       ((image-type-available-p 'xpm)
                                        "emacsportable.xpm")
                                       ((<= (display-planes) 8)
                                        (if (image-type-available-p 'xpm)
                                            "emacsportable.xpm"
                                          "emacsportable.pbm"))
                                       (t "emacsportable.pbm"))))
                             (t (concat usb-app-dir "/img/emacsportable.pbm"))))
           (img (create-image image-file))
           (image-width (and img (car (image-size img))))
           (window-width (window-width (selected-window))))
      (when img
        (when (> window-width image-width)
          ;; Center the image in the window.
          (insert (propertize " " 'display
                              `(space :align-to (+ center (-0.5 . ,img)))))
          
          ;; Change the color of the XPM version of the splash image
          ;; so that it is visible with a dark frame background.
          (when (and (memq 'xpm img)
                     (eq (frame-parameter nil 'background-mode) 'dark))
            (setq img (append img '(:color-symbols (("#000000" . "gray30"))))))
          
          ;; Insert the image with a help-echo and a link.
          (make-button (prog1 (point) (insert-image img)) (point)
                       'face 'default
                       'help-echo "mouse-2, RET: Browse https://github.com/mlf176f2/EmacsPortable.App/"
                       'action (lambda (button) (browse-url "https://github.com/mlf176f2/EmacsPortable.App/"))
                       'follow-link t)
          (insert "\n\n")))))
  
  
  (ep-m "Startup screen")
  
#+end_src

* New frames in EmacsPortable.app
:PROPERTIES:
:ID: ff11d00d-fe0c-499f-9e35-1a3d703bf0c8
:END:
To use the NSIS daemon, we need to be able to start a frame on
demand.  This is done emacsclient -a, but we need to advise the make
frame functions to communicate the status of Emacs with
EmacsPortable.App launcher (is the last frame hidden, is there a
visible frame, etc).  Also, ido needs to set the
`ido-default-file-method' to `selected-window' so that when switching
to a buffer, it does not assume that buffer is in the hidden daemon
frame.  Ido may need to be advised as well to allow `raise-frame' to
work correctly.

#+begin_src emacs-lisp
  (defadvice make-frame (around ep-daemon-new-frame activate)
    "Used to add back the kill emacs functions when a new emacs window is opened."
    (when ep-kill-emacs-query-functions
      (setq kill-emacs-query-functions ep-kill-emacs-query-functions)
      (when (file-exists-p (concat (getenv "TEMP") "/hidden-" emacs-ver
                                   (if (and (getenv "EPSTART")
                                            (not (string= "" (getenv "EPSTART"))))
                                       (concat "-" (getenv "EPSTART"))
                                     "")))
        (delete-file (concat (getenv "TEMP") "/hidden-" emacs-ver
                             (if (and (getenv "EPSTART")
                                      (not (string= "" (getenv "EPSTART"))))
                                 (concat "-" (getenv "EPSTART"))
                               ""))))
      (setq ep-kill-emacs-query-functions nil))
    ad-do-it)
  
  (defadvice new-frame (around ep-daemon-new-frame activate)
    "Used to add back the kill emacs functions when a new emacs window is opened."
    (when ep-kill-emacs-query-functions
      (setq kill-emacs-query-functions ep-kill-emacs-query-functions)
      (when (file-exists-p (concat (getenv "TEMP") "/hidden-" emacs-ver
                                   (if (and (getenv "EPSTART")
                                                (not (string= "" (getenv "EPSTART"))))
                                       (concat "-" (getenv "EPSTART"))
                                     "")))
        (delete-file (concat (getenv "TEMP") "/hidden-" emacs-ver
                             (if (and (getenv "EPSTART")
                                      (not (string= "" (getenv "EPSTART"))))
                                 (concat "-" (getenv "EPSTART"))
                               ""))))
      (setq ep-kill-emacs-query-functions nil))
    ad-do-it)
  
  (defadvice server-execute (around ep-daemon-new-frame activate)
    "Used to delete the %TEMP%/hidden-%EMACSVER% file"
    ad-do-it
    (when (file-exists-p (concat (getenv "TEMP") "/hidden-" emacs-ver
                                 (if (and (getenv "EPSTART")
                                          (not (string= "" (getenv "EPSTART"))))
                                     (concat "-" (getenv "EPSTART"))
                                   "")))
      (delete-file (concat (getenv "TEMP") "/hidden-" emacs-ver
                           (if (and (getenv "EPSTART")
                                                (not (string= "" (getenv "EPSTART"))))
                               (concat "-" (getenv "EPSTART"))
                             "")))))
  
  (defvar ep-kill-emacs-query-functions nil
    "Variable to save `kill-emacs-query-functions'")
  
  (defun new-emacs (&optional rename &rest arg)
    "Starts a new emacs frame (called windows in the rest of the computing world)"
    (interactive)
    (when window-system
      (let (tmp
            (sf (selected-frame)))
        (select-frame (new-frame))
        (when rename
          (modify-frame-parameters (selected-frame)
                                   (list
                                    (cons 'name
                                          (concat "___EmacsPortableDaemon_"
                                                  emacs-ver 
                                                  (if (and (getenv "EPSTART")
                                                           (not (string= "" (getenv "EPSTART"))))
                                                      (concat "_" (getenv "EPSTART"))
                                                    "")
                                                  "___"))))
          (select-frame sf))
        (if (= 0 (length arg))
            (cond
             (t
              (about-emacs)))
          (mapc (lambda(x)
                  (when (file-exists-p x)
                    (find-file x)))
                arg)))))
  
  (setq ido-default-file-method 'selected-window)
  (setq ido-default-buffer-method 'selected-window)
  
#+end_src

* Start the Emacs Server
#+BEGIN_SRC emacs-lisp
    ;; Start server and load-bar.
  (cond 
   ( (eq system-type 'windows-nt) ;; Start daemon even if daemon is not running
    (setq server-auth-dir (concat (getenv "TEMP")
                                  (if window-system 
                                      "\\EmacsPortable.App-Server-"
                                    "\\epd-") emacs-ver
                                    (if (and (getenv "EPSTART")
                                             (not (string= (getenv "EPSTART") "")))
                                        (concat "-" (getenv "EPSTART"))
                                      "")))
    (when (not (file-exists-p server-auth-dir))
      (make-directory server-auth-dir t))
    (require 'server)
    ;; Since this is in the temporary directory it should always be safe.
    (defun server-ensure-safe-dir (&rest args)
      t)
    (when (fboundp 'server-force-delete)
      (server-force-delete))))
  (server-start)
  
  ;; From http://www.emacswiki.org/emacs/EmacsAsDaemon
  (defun linux-client-save-kill-emacs (&optional display)
    " This is a function that can bu used to shutdown save buffers and 
  shutdown the emacs daemon. It should be called using 
  emacsclient -e '(client-save-kill-emacs)'.  This function will
  check to see if there are any modified buffers or active clients
  or frame.  If so an x window will be opened and the user will
  be prompted."
    (let (new-frame modified-buffers active-clients-or-frames)
      ;; Check if there are modified buffers or active clients or frames.
      (setq modified-buffers (modified-buffers-exist-p))
      (setq active-clients-or-frames ( or (> (length server-clients) 1)
                                          (> (length (frame-list)) 1)))  
      
      ;; Create a new frame if prompts are needed.
      (when (or modified-buffers active-clients-or-frames)
        (when (not (eq window-system 'x))
          (message "Initializing x windows system.")
          (x-initialize-window-system))
        (when (not display) (setq display (getenv "DISPLAY")))
        (message "Opening frame on display: %s" display)
        (select-frame (make-frame-on-display display '((window-system . x)))))
      
      ;; Save the current frame.  
      (setq new-frame (selected-frame))
      
      
      ;; When displaying the number of clients and frames: 
      ;; subtract 1 from the clients for this client.
      ;; subtract 2 from the frames this frame (that we just created) and the default frame.
      (when (or (not active-clients-or-frames)
                (yes-or-no-p (format "There are currently %d clients and %d frames. Exit anyway?" (- (length server-clients) 1) (- (length (frame-list)) 2)))) 
        
        ;; If the user quits during the save dialog then don't exit emacs.
        ;; Still close the terminal though.
        (let((inhibit-quit t))
          ;; Save buffers
          (with-local-quit
            (save-some-buffers)) 
          
          (if quit-flag
              (setq quit-flag nil)  
            ;; Kill all remaining clients
            (progn
              (dolist (client server-clients)
                (server-delete-client client))
              ;; Exit emacs
              (kill-emacs)))))
      
      ;; If we made a frame then kill it.
      (when (or modified-buffers active-clients-or-frames)
        (delete-frame new-frame))))
  
  
  (defun modified-buffers-exist-p () 
    "This function will check to see if there are any buffers
  that have been modified.  It will return true if there are
  and nil otherwise. Buffers that have buffer-offer-save set to
  nil are ignored."
    (let (modified-found)
      (dolist (buffer (buffer-list))
        (when (and (buffer-live-p buffer)
                   (buffer-modified-p buffer)
                   (not (buffer-base-buffer buffer))
                   (or
                    (buffer-file-name buffer)
                    (progn
                      (set-buffer buffer)
                      (and buffer-offer-save (> (buffer-size) 0)))))
          (setq modified-found t)))
      modified-found))
  
  (ep-m "EmacsPortable.app")
  (require 'cl)
  
    
  
#+end_src
* Pseudo Daemon
By using autohotkey emacs and nsis, I have implemented a psuedo-daemon
mode for EmacsPortable.

The components for this are:
- The [[*NSIS%20loader%20script][NSIS loader script]]
- The [[Autohotkey script][Autohotkey script]]
- [[NSIS launcher script][NSIS launcher script]]
- [[EmacsPortable.App loader script][EmacsPortable.App loader script]]
** NSIS loader script
:PROPERTIES:
:ID: 918199a7-df18-4abe-a251-033926c0671e
:END:
The [[file:../../Other/source/nsi/loademacs.nsi::%3B%3B%3B%20loademacs.nsi%20---%20Loads%20Emacs][loademacs.nsi]] NSIS script implements a progress bar.  Currently it
is just a psudo-progress bar that really doesn't know when Emacs will
finish loading.  However, by looking at file =runningep.flg= in the
temporary directory, it also tells the user what is loading.  This is
already currently implemented in the emacs minibuffer.  However, if I
am going to hide one of the frames to create a psudo-daemon, the user
will not be able to see this.  Therefore, I implemented this
interface.

Currently it will continue the progress bar until it detects that
=runninep.flg= is no longer in the temporary directory OR =emacs.exe=
is no longer running.

Currently this poses a problem if the site-wide initialization has some
error.  It will continue to load indefinitely.  I'm not currently sure
how to track this except for some large condition-case which deletes
the file when loading.

This has been suspended.  I like looking at emacs while it loads.
There is more information for this type of display.
** Autohotkey script
:PROPERTIES:
:ID: 850a5d6b-f80e-4a2c-b395-ced494a87750
:END:
The auto-hotkey [[file:source/ahk/EmacsPortableServer.ahk::%3B%3B%20(at%20your%20option)%20any%20later%20version.][EmacsPortableServer.ahk]] script keeps the psuedo-daemon
frame from being displayed and subsequently closed on accident.
** NSIS launcher script
:PROPERTIES:
:ID: 1d13200e-3329-4f3a-8320-58d413fe3fd0
:END:
The launcher script launches both the [[id:918199a7-df18-4abe-a251-033926c0671e][NSIS loader script]] and
[[id:850a5d6b-f80e-4a2c-b395-ced494a87750][Autohotkey script]].  Its just a nsis launcher to call both at the same time.
** Start the Psuedo-Daemon
:PROPERTIES:
:ID: 918f409a-aa5b-460d-aaee-5d05926605dd
:END:
#+begin_src emacs-lisp
  ;; Deactivate message advice
  ;;(ad-disable-advice 'message 'around 'ep-loadup-bar-advice)
  (when window-system
    (when (and (string-equal system-type "windows-nt")
               (getenv "EMACS_DAEMON"))
      (setq ep-server t)
      (new-emacs t)))
  
#+end_src

** Mimicking the kill-emacs behavior in the daemon
:PROPERTIES:
:ID: 30d39dde-8336-4c3b-93c4-ae49496c1e2b
:END:

While the Pseudo-Daemon shouldn't be exited, it should appear to the
user that they have exited emacs. To do this, when only one frame is
visible, the following is required:

- Ask to save all buffers
- Run the corresponding =kill-emacs-query-functions=
- If these are successful, kill the current frame, and reassign the
  hooks to nil (saving the value) so that a subsequent real kill-emacs
  won't have to run these hooks again.

To do this, I need to mimic =save-buffers-kill-emacs= when there is
only one frame left other than the hidden =___EmacsPortableDaemon_%version___=
frame.

The first step is to create a special function that:

 1. Sets an external variable, =ep-emacs-kill-frame= to t
 2. Returns nil,

By appending this function to the =kill-emacs-query-functions= hook and calling
=save-buffers-kill-emacs=, Emacs should run all the appropriate
functions and set =ep-emacs-kill-frame= if the Emacs frame should be
killed. Using this we can create a function that:

 - Adds and removes the special function
   (=ep-save-buffers-pseudo-kill-emacs=) to the =kill-emacs-query-functions= so
   that it can run =save-buffers-kill-emacs= without actually killing
   emacs.
 - If all the queries are successful,
   + Save the =kill-emacs-query-functions= to an
     external variable and set to nil
   + Return t
 - Otherwise return nil

#+begin_src emacs-lisp
  (defvar ep-emacs-kill-frame nil
    "Variable that tells if the pseudo-kill-emacs run was sucessful.")
  (defun ep-save-buffers-nil-fn ()
    "This function returns nil and sets ep-emacs-kill-frame to t"
    (setq ep-emacs-kill-frame t)
    nil)
  (defvar ep-kill-emacs-hook nil
    "True Kill Emacs hook.")
  (defvar ep-saved-kill-emacs-hook nil)
  (defun ep-save-buffers-pseudo-kill-emacs ()
    "Faking `save-buffers-kill-emacs' when last visible frame is removed."
    (let ((server (memq 'server-force-stop kill-emacs-hook)))
      (setq ep-kill-emacs-query-functions nil)
      (add-hook 'kill-emacs-query-functions 'ep-save-buffers-nil-fn t)
      (save-buffers-kill-emacs)
      (remove-hook 'kill-emacs-query-functions 'ep-save-buffers-nil-fn)
      (setq ep-saved-kill-emacs-hook kill-emacs-hook)
      (when server
        (remove-hook 'kill-emacs-hook 'server-force-stop))
      (run-hooks 'kill-emacs-hook)
      (setq kill-emacs-hook nil)
      (when server
        (add-hook 'kill-emacs-hook 'server-force-stop))
      (if (not ep-emacs-kill-frame) nil
        (setq ep-emacs-kill-frame nil)
        (setq ep-kill-emacs-query-functions kill-emacs-query-functions)
        (unless (file-exists-p (concat (getenv "TEMP") "/hidden-" emacs-ver
                                       (if (and (getenv "EPSTART")
                                                (not (string= "" (getenv "EPSTART"))))
                                           (concat "-" (getenv "EPSTART"))
                                         "")))
          (with-temp-file (concat (getenv "TEMP") "/hidden-" emacs-ver
                                  (if (and (getenv "EPSTART")
                                           (not (string= "" (getenv "EPSTART"))))
                                      (concat "-" (getenv "EPSTART"))
                                    ""))
            (insert "hidden")))
        (setq kill-emacs-query-functions nil)
        t)))
  
  (defadvice save-buffers-kill-emacs (around ep-save-buffer-kill-emacs activate)
    "Checks to see if `ep-kill-emacs-query-functions' has functions
  stored in it.  If it does, do not try to save files again (they
  should have already been prompted for)."
    (cond
     (ep-kill-emacs-query-functions
         (kill-emacs))
     (t
      ad-do-it)))
  
#+end_src

The last step is to call this when the last frame is being deleted.

#+begin_src emacs-lisp
  (defun ep-is-last-frame-p ()
    "Determines if this is the last frame (only under Windows-nt)"
    (when (and (getenv "EMACS_DAEMON") 
               (string-equal system-type "windows-nt"))
      (let ((frames (frame-list))
            server-found
            ret)
        (when (and ep-server (= 2 (length frames)))
          (mapc (lambda(frame)
                  (setq server-found 
                        (or server-found
                            (string= (concat "___EmacsPortableDaemon_"
                                             emacs-ver
                                             (if (and (getenv "EPSTART")
                                                      (not (string= "" (getenv "EPSTART"))))
                                                 (concat "_" (getenv "EPSTART"))
                                               "")
                                             "___")
                                     (format "%s" (frame-parameter frame 'name))))))
                frames)
          (when server-found
            (setq ret t)))
        ret)))
  
  (defvar ep-delete-frame-hooks nil)
  
  (defun ep-del-frame-query ()
    "Queries to delete frame."
    (if (not (ep-is-last-frame-p)) t
      (ep-save-buffers-pseudo-kill-emacs)))
  
  (add-hook 'ep-delete-frame-hooks 'ep-del-frame-query)
  
  (defadvice delete-frame (around ep-delete-frame activate)
    "Advice to only call delete-frame if `ep-delete-frame-hooks'
  are run successfully."
    (when (run-hook-with-args-until-failure 'ep-delete-frame-hooks)
      ad-do-it))
  
#+end_src
* Keep from customization collision
Try to set things in a way that dosen't affect customize.  Lifted from
ECB and emacswiki frame-cmds, http://www.emacswiki.org/emacs/frame-cmds.el
#+BEGIN_SRC emacs-lisp
  (defmacro ep-tell (variable)
    "Tell Customize to recognize that VARIABLE has been set (changed).
  VARIABLE is a symbol that names a user option."
    `(put ,variable 'customized-value (list (custom-quote (eval ,variable)))))
  
  (defmacro ep-saved-p (option)
    "Return only not nil if OPTION is a defcustom-option and has a
  saved value. Option is a variable and is literal \(not evaluated)."
    `(and (get (quote ,option) 'custom-type)
          (get (quote ,option) 'saved-value)))
  
  (defmacro ep-setq (option value)
    "Sets OPTION to VALUE if and only if OPTION is not already saved
  by customize. Option is a variable and is literal \(not evaluated)."
    `(and (not (ep-saved-p ,option))
          (set (quote ,option) ,value)
          (ep-tell (quote ,option))))
  
#+END_SRC

* Needed starting settings
** Frame name
:PROPERTIES:
:ID: 883e8775-2cfc-4e44-b51f-800598e14c80
:END:
#+begin_src emacs-lisp
  (if (eq system-type 'windows-nt)
      (setq frame-title-format
            (list (with-temp-buffer
                    (insert "Emacs")
                    (insert (if (string= (downcase (substring usb-drive-letter 0 1))
                                         (downcase (substring data-directory 0 1)))
                                (concat "Portable@"
                                        (downcase (substring usb-drive-letter 0 1)))
                              "Local"
                              ))
                    (insert "-")
                    (insert emacs-ver)
                    (when (and (getenv "EPSTART")
                               (not (string= "" (getenv "EPSTART"))))
                      (insert (format " (%s)" (getenv "EPSTART"))))
                    (insert " %b")
                    (buffer-substring (point-min) (point-max)))
                  '(buffer-file-name ": %f")))
    (setq frame-title-format (list "EmacsPortable %b" '(buffer-file-name ": %f"))))
  
#+end_src
* Miscellaneous
** Spell Checking
*** Hunspell
:PROPERTIES:
:ID: 65a4feb0-5ec6-47aa-af4f-f99200144497
:END:
Hunspell is supposed to be a better spell-checker than apsell.  It is
what firefox and open office use.
#+begin_src emacs-lisp
  (condition-case err
      (progn
        (setenv "LANG" "en")
        (require 'rw-language-and-country-codes nil t)
        (require 'rw-ispell nil t)
        (require 'rw-hunspell nil t)
        (setq rw-hunspell-make-dictionary-menu t)
        (setq rw-hunspell-use-rw-ispell t)
        (setq ispell-program-name (executable-find "hunspell"))
        ;;(setq rw-hunspell-dicpath-list (list (getenv "DICPATH")))
        (rw-hunspell-setup))
    (error nil))  
#+end_src
*** Flyspell
:PROPERTIES:
:ID: 5503a001-551f-4692-9b67-33a69832ea61
:END:
I prefer right-click for correct word.
#+begin_src emacs-lisp
  (require 'flyspell)
  (define-key flyspell-mouse-map  [down-mouse-3] #'flyspell-correct-word)
#+end_src
** Other Options
:PROPERTIES:
:ID: fe11bef7-d27f-4fc1-a769-b02504d8a4dd
:END:
#+begin_src emacs-lisp
  (setq message-log-max 10000)

  ;; Keep cursor out of the prompt
  (setq minibuffer-prompt-properties
        (plist-put minibuffer-prompt-properties
                   'point-entered 'minibuffer-avoid-prompt))
#+end_src

** Display Options
:PROPERTIES:
:ID: dc551326-c4b8-46a2-8a9c-21e872da6af6
:END:
#+begin_src emacs-lisp
(setq default-indicate-empty-lines t)
(setq mode-line-in-non-selected-windows  t)
(setq default-indicate-buffer-boundaries  t)
(setq overflow-newline-into-fringe  t)
#+end_src
*** Mode Line
:PROPERTIES:
:ID: 7f6f9885-e1eb-47af-bd32-2877aef7e2a7
:END:
Put current line number and column in the mode line
#+begin_src emacs-lisp
(line-number-mode 1)
(setq column-number-mode t)
#+end_src
** Update Paths
:PROPERTIES:
:ID: 9f86eea2-d782-479e-b0ab-24360af6d529
:END:
Make sure the Emacs Path environment matches the command environment
path.

All paths should be in the nsis startup script.

* Fix problems with some crossover problems.
Unfortunately, running EmacsPortable.App from the same location on
different systems can cause some problems for Mac OSX.  It doesn't
understand certain file types, like =c:/autoexec.bat=.  Therefore it
sends them to TRAMP. Certain things should just return nil.  This can
be fixed by advices on some primitive functions

#+BEGIN_SRC emacs-lisp
  (defadvice file-readable-p (around emacs-portable-advice activate)
    "This advice keeps Emacs from trying to call tramp on c:/ and othe windows-type files when running Mac OSX."
    (if (and (eq system-type 'darwin)
               (save-match-data
                 (string-match "^[A-Za-z]:[/\\]" (nth 0 (ad-get-args 0))))) nil
      ad-do-it))
  
  (defadvice file-remote-p (around emacs-portable-advice activate)
    "This advice keeps Emacs from assuming that c:\ is a remote file and trying to connect to a remote that doesn't exist."
    (if (and (eq system-type 'darwin)
             (save-match-data
               (string-match "^[A-Za-z]:[/\\]" (nth 0 (ad-get-args 0))))) t
      ad-do-it))
  
  (defadvice file-exists-p (around emacs-portable-advice activate)
    "This advice keeps Emacs from trying to call tramp on c:/ and othe windows-type files when running Mac OSX."
    (if (and (eq system-type 'darwin)
             (save-match-data
               (string-match "^[A-Za-z]:[/\\]" (nth 0 (ad-get-args 0))))) nil
      ad-do-it))
#+END_SRC

* Add TRAMP support under windows
Using putty, you may add tramp support.  This is the emacs piece of
the implementation 
#+BEGIN_SRC emacs-lisp
  (require 'tramp)
  (when (and
         (executable-find "plink"))
    (ep-m "Tramp (for Putty)")
    (setq tramp-default-method "plink"))
#+END_SRC

When using ido, ido puts tramp in the file history unless they are
ignored.  This causes ido-mode to freeze emacs startup waiting on
remote sites.  This can be fixed by the following code:

#+BEGIN_SRC emacs-lisp
  (require 'ido)
  (add-to-list 'ido-work-directory-list-ignore-regexps tramp-file-name-regexp)
#+END_SRC

This is discussed http://stackoverflow.com/questions/10397687/stop-tramp-from-opening-remote-directories-when-using-ido-mode


* Taking off ido caching on windows
Taken from http://wikemacs.org/wiki/Ido.

On Windows operating systems it can be unreliable to cache directory
listings: the directory may not appear to be modified even though
files have been added or removed. Ido caches directory listings by
default, which may cause confusion on Windows. You can disable
caching:

#+BEGIN_SRC emacs-lisp
  (when (equal system-type 'windows-nt)
    (setq ido-max-dir-file-cache 0)) ; caching unreliable
#+END_SRC

* Fix mac/windows communication issues on mac.
#+BEGIN_SRC emacs-lisp
    (when (eq system-type 'darwin)
      (setq tramp-file-name-regexp-unified "\\`/\\([^[/:]\\{2,\\}\\|[^/]\\{2,\\}]\\):")
      (require 'tramp)
      (when (assoc "\\`/\\([^[/:]+\\|[^/]+]\\):" file-name-handler-alist)
        (let ((a1 (rassq 'tramp-file-name-handler file-name-handler-alist)))
          (setq file-name-handler-alist (delq a1 file-name-handler-alist))
          (add-to-list 'file-name-handler-alist
                       `("\\`/\\([^[/:]\\{2,\\}\\|[^/]\\{2,\\}]\\):" . tramp-file-name-handler)))))
    
#+END_SRC
* Fix Proxy settings for various programs
Proxy settings moved to site-init.el so that automatic (re)compilation
can be performed.
* Fix saving settings for various computers
When using EmacsPortable.App in Windows & MacOS, a single =~/.ido.last=
caching mechanism does not work.  The windows file history causes the
Mac version to choke and not startup.  Strangely UNIX-based
file systems do not understand the =c:/= caching.  Therefore, I am
going to change the =~/.ido.last= to
=Data/saves/ido-last-system-name= that way there is an ido-completion
for each system that EmacsPortable runs on.  This is true for many
save files.

#+BEGIN_SRC emacs-lisp
  (setq desktop-dirname (concat usb-site-lisp-dir "../Data/saves/desktop-"
                                system-name)
        user-emacs-directory (concat (expand-file-name ".emacs.d"
                                               (getenv "HOME")) "/")
        savehist-file  (concat usb-site-lisp-dir "../Data/saves/history")
        save-place-file (concat usb-site-lisp-dir "../Data/saves/places-"
                                system-name)
        ido-save-directory-list-file (concat usb-site-lisp-dir
                                             "../Data/saves/ido-last-" system-name)
        bookmark-default-file (concat usb-site-lisp-dir "../Data/saves/emacs-"
                                      system-name ".bmk"))
  (when (not (file-exists-p desktop-dirname))
    (make-directory desktop-dirname t))
  
#+END_SRC
* Start a shared startup-script, if present.
Start the appropriate startup script
#+BEGIN_SRC emacs-lisp
  (when (and (getenv "EPSTART")
             (not (string= "" (getenv "EPSTART")))
             (getenv "EPSTARTDIR")
             (file-exists-p (getenv "EPSTARTDIR")))
    (let ((start-dir (getenv "EPSTARTDIR")))
      (when start-dir
        (setq start-dir (expand-file-name (getenv "EPSTARTDIR")))
        ;; Make sure that the ELPA directories are per each startup group.
        (unless (file-exists-p (expand-file-name "elpa" (getenv "EPSTARTDIR")))
          (make-directory (expand-file-name "elpa" (getenv "EPSTARTDIR")) t))
        (setq package-user-dir (expand-file-name "elpa" (getenv "EPSTARTDIR")))
        (message "Using startup at %s" start-dir)
        (cond
         ((file-exists-p (expand-file-name ".emacs" start-dir))
          (load (expand-file-name ".emacs" start-dir))
          (message "Loaded %s/.emacs" start-dir))
         
         ((file-exists-p (expand-file-name "init.el" start-dir))
          (load (concat (replace-regexp-in-string "/$" "" start-dir t t) "/init"))
          (message "Loaded %s/init" (replace-regexp-in-string "/$" "" start-dir t t)))
         
         ((file-exists-p (expand-file-name  "site-start.el" (expand-file-name "site-lisp" start-dir)))
          (load (concat (expand-file-name "site-lisp" start-dir) "/site-start"))
          (message "Loaded %s/site-start/site-lisp" start-dir))))))
  
  
#+END_SRC

* Load Emacs Terminal settings for Windows 32, adapted from emacsW32
#+BEGIN_SRC emacs-lisp
  (when (and
         (eq system-type 'windows-nt)
         (file-exists-p (expand-file-name "epshell.el"
                                          (expand-file-name "site-lisp" usb-app-dir))))
    (load (concat (expand-file-name "site-lisp" usb-app-dir) "/epshell")))
#+END_SRC

* Load Emacs Full-Screen support
** Under Windows
https://bitbucket.org/phromo/w32-fullscreen/downloads
#+BEGIN_SRC emacs-lisp
  (when (and
         (eq system-type 'windows-nt)
         (file-exists-p (expand-file-name "w32-fullscreen.el"
                                          (expand-file-name "site-lisp" usb-app-dir)))
         (file-exists-p (expand-file-name "w32toggletitle.exe"
                                          (expand-file-name "site-lisp" usb-app-dir))))
    (setq w32-fullscreen-toggletitle-cmd (expand-file-name "w32toggletitle.exe"
                                                           (expand-file-name "site-lisp" usb-app-dir)))
    (load (concat (expand-file-name "site-lisp" usb-app-dir) "/w32-fullscreen"))
    (global-set-key [f11] 'w32-fullscreen))
  
  (when (file-exists-p (expand-file-name "maxframe.el"
                                         (expand-file-name "site-lisp" usb-app-dir)))
    (load (concat (expand-file-name "site-lisp" usb-app-dir) "/maxframe")))
  
  (add-hook 'after-make-frame-functions 'ep-maximize-frame)
  (defvar ep-maximize-frame-cached nil)
  (defvar ep-maximize-frame-cache nil)
  (defun ep-maximize-frame (frame)
    "Maximizes FRAME, when selected in EmacsPortableApp.ini"
    (interactive (list (selected-frame)))
    (when (or (and ep-maximize-frame-cached ep-maximize-frame-cache)
              (and (not ep-maximize-frame-cached)
                   (with-temp-buffer
                     (insert-file-contents "~ini/EmacsPortableApp.ini")
                     (goto-char (point-min))
                     (setq ep-maximize-frame-cached t)
                     (setq ep-maximize-frame-cache
                           (re-search-forward "^[ \t]*[Mm]ax[Aa]pply[Nn]ew[ \t]*=[ \t]*1[ \t]*$" nil t))
                     (symbol-value 'ep-maximize-frame-cache))))
      (cond
       ((fboundp 'maximize-frame)
        (maximize-frame))
       ((eq system-type 'windows-nt)
        (select-frame frame)
        (w32-send-sys-command #xf030))
       (t))))
  
#+END_SRC

* Load System, User, and Shared Initialization files
** Load source function
Load either an encrypted org-file, an org-file, a lisp file, or a
compiled lisp file.  Delete intermediary files

#+BEGIN_SRC emacs-lisp
  (defun ep-load-org (file)
    "Loads Emacs Lisp source code blocks like `org-babel-load-file'.  However, byte-compiles the files as well as tangles them..."
    (flet ((age (file)
                (float-time
                 (time-subtract (current-time)
                                (nth 5 (or (file-attributes (file-truename file))
                                           (file-attributes file)))))))
      (let* ((base-name (file-name-sans-extension file))
             (exported-file (concat base-name ".el"))
             (compiled-file (concat base-name ".elc")))
        (message "Base Name %s" base-name)
        (unless (and (file-exists-p exported-file)
                     (> (age file) (age exported-file)))
          (message "Trying to Tangle %s" file)
          (condition-case err
              (progn
                (org-babel-tangle-file file exported-file "emacs-lisp")
                (ep-m (format "Tangled %s to %s"
                              file exported-file)))
            (error (message "Error Tangling %s" file))))
        (when (file-exists-p exported-file)
          (if (and (file-exists-p compiled-file)
                   (> (age exported-file) (age compiled-file)))
              (progn
                (condition-case err
                    (load-file compiled-file)
                  (error (message "Error Loading %s" compiled-file)))
                (ep-m (format "Loaded %s" compiled-file)))
            (condition-case err
                (byte-compile-file exported-file t)
              (error (message "Error Byte-compiling and loading %s" exported-file)))
            (ep-m (format "Byte-compiled & loaded %s" exported-file))
            ;; Fallback and load source
            (if (file-exists-p compiled-file)
                (set-file-times compiled-file) ; Touch file.
              (condition-case err
                  (load-file exported-file)
                (error (message "Error loading %s" exported-file)))
              (ep-m (format "Loaded %s since byte-compile failed."
                            exported-file))))))))
  
  (defun ep-load-user (name)
    "Loads a user-name's configuration"
    (ep-load-user-or-system name t))
  (defun ep-load-system (name)
    "Loads a system configuration"
    (ep-load-user-or-system name))
  
  (defun ep-load-init-dir (&optional dir-name)
    (let ((name (or dir-name (if (getenv "EPDATA")
                                 (concat (getenv "EPDATA") "/start/shared")
                               (concat usb-app-dir "../Data/start/shared")))))
      (ep-load-user-or-system nil nil name)))    
  
  (defun ep-load-user-or-system (name &optional is-user is-dir)
    "Loads either a user-name's configuration OR system
    configuration.  This prefers org-files and will compile them as
    far as possible.  It can accept many .el and .elc files if their
    upstream program is not available/found
    "
    (flet ((in-dir (file &optional ext)
                   (expand-file-name (concat file ext)
                                     (or is-dir
                                         (concat usb-app-dir 
                                                 (if (getenv "EPDATA")
                                                     (concat (getenv "EPDATA") "/start/")
                                                     "../Data/start/")
                                                 (if is-user
                                                     "user"
                                                   "system")))))
           (age (file)
                (float-time
                 (time-subtract (current-time)
                                (nth 5 (or (file-attributes (file-truename file))
                                           (file-attributes file))))))
           (load-cfg (ini-file)
                     (let* ((base-name (file-name-sans-extension ini-file))
                            (org-gpg (concat base-name ".org.gpg"))
                            (org (concat base-name ".org"))
                            (file (concat base-name ".el"))
                            (compiled-file (concat base-name ".elc")))
                       (if (file-readable-p org-gpg)
                           (ep-load-org org-gpg)
                         (if (file-readable-p org)
                             (ep-load-org org)
                           (if (file-readable-p file)
                               (when (file-exists-p file)
                                 (if (and (file-exists-p compiled-file)
                                          (> (age file) (age compiled-file)))
                                     (load-file compiled-file)
                                   (byte-compile-file file t)
                                   ;; Fall-back and load source
                                   (unless (file-exists-p compiled-file)
                                     (load-file file))))
                             (if (file-readable-p compiled-file)
                                 (load-file compiled-file))))))))
      (flet ((dir-cfgs (dir)
                       ;; Return a list of highest level configuration org,
                       ;; el elc, and then load the configuration.
                       (when (file-readable-p dir)
                         (add-to-list 'load-path dir)
                         (let ((files (directory-files dir t ".*[.]\\(org\\(.gpg\\)?\\|el\\|elc\\)$")))
                           (setq files (remove-if #'(lambda(item)
                                                      (let ((base-name (file-name-sans-extension item)))
                                                        (cond
                                                         ((string-match "elc$" item)
                                                          (or (file-readable-p (concat base-name ".el"))
                                                              (file-readable-p (concat base-name ".org"))
                                                              (file-readable-p (concat base-name ".gpg"))))
                                                         ((string-match "el$" item)
                                                          (or (file-readable-p (concat base-name ".org"))
                                                              (file-readable-p (concat base-name ".gpg"))))
                                                         (t
                                                          nil))))
                                                  files))
                           (mapc (lambda(file)
                                   (message "Loading %s" file)
                                   (load-cfg file))
                                 files)))))
        (let ((org2 (in-dir name ".org"))
              (dir2 (in-dir name)))
          (if is-dir
              (progn
                (dir-cfgs is-dir))
            (load-cfg org2)
            (dir-cfgs dir2))))))
  
  (condition-case err
      (ep-load-init-dir)
    (error (ep-m "Error loading initialization scripts %s" err)))
  
  (condition-case err
      (ep-load-system system-name)
    (error (ep-m "Error loading system initialization scripts %s" err)))
  
  (condition-case err
      (ep-load-user user-login-name)
    (error (ep-m "Error Loading user initialization scripts %s" err)))
  
  
#+END_SRC
* Attempt to sync background and foreground colors with startup options
This attempts to sync color options with the startup options in EmacsPortable.App
#+BEGIN_SRC emacs-lisp
  (defun emacs-portable-sync-display ()
    "Sync Emacs colors with startup options"
    (interactive)
    (let* ((fp (frame-parameters))
           (bg (cdr (assoc 'background-color fp)))
           (fg (cdr (assoc 'foreground-color fp)))
           (font (cdr (assoc 'font fp)))
           (font-name (if (string-match "-.*?-\\(.*?\\)-" font)
                          (match-string 1 font)
                        nil))
           (font-size (if (string-match "\\(?:-.*?\\)\\{6\\}-\\([0-9]*\\)" font)
                          (progn
                            (/ (* 72 (string-to-number (match-string 1 font))) 96))
                        nil)))
      (flet ((fix (var name)
                  (when var
                    (goto-char (point-min))
                    (if (not (re-search-forward (format "%s=.*" name) nil t))
                        (progn
                          (goto-char (point-max))
                          (insert name "=" var "\n"))
                      (replace-match (format "%s=%s" name var) t t)))))
        (with-temp-buffer
          (insert-file-contents "~ini/EmacsPortableApp.ini")
          (fix fg "Foreground")
          (fix bg "Background")
          (fix font-name "Font")
          (fix font-size "FontSize")
          (write-file "~ini/EmacsPortableApp.ini")))))
  
  ;; Sync with load-theme in emacs24.
  (defadvice load-theme (around emacs-portable-theme-sync activate)
    "Syncs Background and Foreground colors with startup options."
    ad-do-it
    (emacs-portable-sync-display))
  
#+END_SRC

* Setup org-mode files
** MathToWeb
See [[http://orgmode.org/manual/Working-with-LaTeX-math-snippets.html#fn-1][Working with @LaTeX{} math snippets - The Org Manual]] for MathToWeb
Explanation

#+BEGIN_SRC emacs-lisp
  (when (file-exists-p "~app/jar/mathtoweb.jar")
    (setq org-latex-to-mathml-convert-command
          "java -jar %j -unicode -force -df %o %I"
          org-latex-to-mathml-jar-file
          (expand-file-name "mathtoweb.jar" "~app/jar")))
#+END_SRC

** PlantUML
To use PlantUML in org mode the setup is detailed at the website:
[[http://eschulte.me/babel-dev/DONE-integrate-plantuml-support.html][Org-babel-dev: DONE integrate plantuml support]].

If the jar is found in =~app/jar/plantuml.jar= and graphviz portable
is installed, you may set the required variables below:
#+BEGIN_SRC emacs-lisp
  (when (file-exists-p "~app/jar/plantuml.jar")
    (setq org-plantuml-jar-path
          (expand-file-name "~app/jar/plantuml.jar"))
    (setq plantuml-jar-path
          (expand-file-name "~app/jar/plantuml.jar")))
  
#+END_SRC

Note that you will have to add the following to org-mode languages:

#+BEGIN_SRC emacs-lisp :tangle no
;; active Org-babel languages
(org-babel-do-load-languages
 'org-babel-load-languages
 '(;; other Babel languages
   (plantuml . t)))
#+END_SRC

* Setup EmacsPortable build/update functions
These functions allow updating/building of EmacsPortable.App
distributions.

#+BEGIN_SRC emacs-lisp
  (autoload 'emacs-portable-update-offical-emacs-releases "update-emacsportable" nil t)
  (autoload 'build-nsi "build-nsi" nil t)
  
#+END_SRC

* Setup Yasnippet information
 This sets up the yansippets located under =~data/snippets=
 #+BEGIN_SRC emacs-lisp
   (when (not (file-exists-p (expand-file-name "~data/snippets")))
     (make-directory (expand-file-name "~data/snippets")))
   
   (if (fboundp 'yas-load-directory)
       (yas-load-directory  (expand-file-name "~data/snippets"))
     (when (fboundp 'yas/load-directory)
       (yas/load-directory  (expand-file-name "~data/snippets"))))
 #+END_SRC
