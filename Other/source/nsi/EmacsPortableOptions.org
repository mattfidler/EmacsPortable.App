#+TITLE: EmacsPortable Startup Options
#+AUTHOR: Matthew L. Fidler
#+PROPERTY: tangle EmacsPortableOptions.nsi
* Introduction
This provides an interface to the Emacs Startup options
* Header
** Compression and other options
#+BEGIN_SRC nsis
  CRCCheck On
  RequestExecutionLevel user
  ; Best Compression
  SetCompress Auto
  SetCompressor /SOLID lzma
  SetCompressorDictSize 32
  SetDatablockOptimize On
#+END_SRC
** Definitions and Variables
#+BEGIN_SRC nsis
  !define TEMP1 $R0 ;Temp variable
  
#+END_SRC
** Include files
#+BEGIN_SRC nsis
  !include "MUI2.nsh"
  !include "LogicLib.nsh"
  !include "FileFunc.nsh"
  !include "emacsproxy.nsh"
  !include "setupEmacsData.nsh"
  !include "CommCtrl.nsh"
#+END_SRC
** nsDialogs Hacks
*** Sorted DropList
See
http://nsis.sourceforge.net/NsDialogs_FAQ#How_to_create_a_sorted_droplist_control
#+BEGIN_SRC nsis
/*
nsDialogs_createDroplistSorted.nsh
Header file for creating a sorted droplist control.
 
Usage:
  ${NSD_CreateDroplistSorted} left top width height ""
  Creates the sorted droplist at the location specified.
*/
 
!ifndef NSDIALOGS_createDroplistSorted_INCLUDED
	!define NSDIALOGS_createDroplistSorted_INCLUDED
	!verbose push
	!verbose 3
 
	!include WinMessages.nsh
 
	!define __NSD_DropListSorted_CLASS COMBOBOX
	!define __NSD_DropListSorted_STYLE ${DEFAULT_STYLES}|${WS_TABSTOP}|${WS_VSCROLL}|${WS_CLIPCHILDREN}|${CBS_AUTOHSCROLL}|${CBS_HASSTRINGS}|${CBS_DROPDOWNLIST}|${CBS_SORT}
	!define __NSD_DropListSorted_EXSTYLE ${WS_EX_WINDOWEDGE}|${WS_EX_CLIENTEDGE}
 
	!insertmacro __NSD_DefineControl DropListSorted
 
	!verbose pop
!endif
#+END_SRC
*** Sorted ComboBox (if possible)
#+BEGIN_SRC nsis
  !ifndef NSDIALOGS_createComboBoxSorted_INCLUDED
    !define NSDIALOGS_createComboBoxSorted_INCLUDED
    !verbose push
    !verbose 3
    
    !include WinMessages.nsh
    !define __NSD_ComboBoxSorted_CLASS COMBOBOX
    !define __NSD_ComboBoxSorted_STYLE ${DEFAULT_STYLES}|${WS_TABSTOP}|${WS_VSCROLL}|${WS_CLIPCHILDREN}|${CBS_AUTOHSCROLL}|${CBS_HASSTRINGS}|${CBS_DROPDOWN}|${CBS_SORT}
    !define __NSD_ComboBoxSorted_EXSTYLE ${WS_EX_WINDOWEDGE}|${WS_EX_CLIENTEDGE}
    !insertmacro __NSD_DefineControl ComboBoxSorted
    !verbose pop
  !endif
  
#+END_SRC

** Name,Branding and Output file
#+BEGIN_SRC nsis
  Name "EmacsPortable.App Options"
  OutFile "..\..\..\EmacsOptions.exe"
  BrandingText "PortableEmacs.App"
  
  InstallDir "$EXEDIR"
#+END_SRC
** Modern User Interface Options
#+BEGIN_SRC nsis
  !define MUI_ICON "..\img\ico\preferences_system.ico"
  #!define MUI_UNICON
  !define MUI_HEADERIMAGE
  
  !define MUI_HEADERIMAGE_BITMAP "..\img\headerimage-options.bmp" ; 150x57 pixels
  !define MUI_HEADERIMAGE_UNBITMAP "..\img\headerimage-options.bmp" ; 150x57 pixels
  
  !define MUI_WELCOMEFINISHPAGE_BITMAP "..\img\welcome-options.bmp" ;164x314 pixels
  !define MUI_UNWELCOMEFINISHPAGE_BITMAP "..\img\welcome-options.bmp" ;164x314 pixels
  
  !define MUI_ABORTWARNING
  !define MUI_UNABORTWARNING
  !define MUI_PAGE_HEADER_TEXT "EmacsPortable.app"
  !define MUI_PAGE_HEADER_SUBTEXT "Emacs on the Go"
  
  !define MUI_COMPONENTSPAGE_SMALLDESC
  !define MUI_HEADERIMAGE_RIGHT
#+END_SRC

** NSIS Pages
#+BEGIN_SRC nsis
  ;Order of pages
  Page custom fnc_visuals_Show fnc_visuals_Validate
  Page custom fnc_behavior_Show fnc_behavior_Validate
  !insertmacro MUI_PAGE_INSTFILES
  !insertmacro MUI_PAGE_FINISH
  !insertmacro MUI_LANGUAGE "English"
  
#+END_SRC
* Macros
** Read/Write Macros
#+BEGIN_SRC nsis  
  !macro SetCheck VARIABLE OPT 
    ReadIniStr $R0 "$EXEDIR\Data\ini\EmacsPortableApp.ini" "EmacsPortableApp" "${OPT}"
    ${If} $R0 == "1"
      ${NSD_Check} ${VARIABLE}
    ${ElseIf} ${Errors}
      ${NSD_Check} ${VARIABLE}
    ${Else}
      ${NSD_UnCheck} ${VARIABLE}
    ${EndIf}
    ClearErrors
  !macroend
  !define SetCheck `!insertmacro SetCheck`
  
  !macro SetUnCheck VARIABLE OPT 
    ReadIniStr $R0 "$EXEDIR\Data\ini\EmacsPortableApp.ini" "EmacsPortableApp" "${OPT}"
    ${If} $R0 == "1"
      ${NSD_Check} ${VARIABLE}
    ${ElseIf} ${Errors}
      ${NSD_UnCheck} ${VARIABLE}
    ${Else}
      ${NSD_UnCheck} ${VARIABLE}
    ${EndIf}
    ClearErrors
  !macroend
  !define SetUnCheck `!insertmacro SetUnCheck`
  
  !macro SetUnRadio  VARIABLE OPT
    
  !macroend
  !define SetUnRadio `!insertmacro SetUnRadio`
  !macro SetDir VARIABLE OPT ERR
    ReadIniStr $R0 "$EXEDIR\Data\ini\EmacsPortableApp.ini" "EmacsPortableApp" "${OPT}"
    ${If} ${Errors}
      StrCpy $R0 "${ERR}"
    ${EndIf}
    ${NSD_SetText} ${VARIABLE} $R0
    
  !macroend
  !define SetDir `!insertmacro SetDir`
  !define SetText `!insertmacro SetDir`
  
  !macro WriteCheck VARIABLE OPT
    ${NSD_GetState} ${VARIABLE} $R0
    ${If} $R0 == ${BST_CHECKED}
      WriteIniStr "$EXEDIR\Data\ini\EmacsPortableApp.ini" "EmacsPortableApp" \
          "${OPT}" "1"
    ${Else}
      WriteIniStr "$EXEDIR\Data\ini\EmacsPortableApp.ini" "EmacsPortableApp" \
          "${OPT}" "0"
    ${EndIf}  
  !macroend
  !define WriteCheck `!insertmacro WriteCheck`
  
  !macro WriteText VARIABLE OPT
    ${NSD_GetText} ${VARIABLE} $R0
    WriteIniStr "$EXEDIR\Data\ini\EmacsPortableApp.ini" "EmacsPortableApp" \
        "${OPT}" "$R0"
  !macroEnd
  !define WriteText `!insertmacro WriteText`
  
  !macro WriteCB VARIABLE OPT
    ${NSD_CB_GetSelection} ${VARIABLE} $R0
    WriteIniStr "$EXEDIR\Data\ini\EmacsPortableApp.ini" "EmacsPortableApp" \
        "${OPT}" "$R0"
  !macroend
  !define WriteCB `!insertmacro WriteCB`
  
  
#+END_SRC
** StrSlash
#+BEGIN_SRC nsis
  ## StringSlash
  !macro _StrSlash FILENAME SLASH
    Push "${FILENAME}"
    Push "${SLASH}"
    Call StrSlash
    Pop $R0
  !macroend
  !define StrSlash `!insertmacro _StrSlash`
  ; Push $filenamestring (e.g. 'c:\this\and\that\filename.htm')
  ; Push "\"
  ; Call StrSlash
  ; Pop $R0
  ; ;Now $R0 contains 'c:/this/and/that/filename.htm'
  Function StrSlash
    Exch $R3 ; $R3 = needle ("\" or "/")
    Exch
    Exch $R1 ; $R1 = String to replacement in (haystack)
    Push $R2 ; Replaced haystack
    Push $R4 ; $R4 = not $R3 ("/" or "\")
    Push $R6
    Push $R7 ; Scratch reg
    StrCpy $R2 ""
    StrLen $R6 $R1
    StrCpy $R4 "\"
    StrCmp $R3 "/" loop
    StrCpy $R4 "/"
    
    loop:
      StrCpy $R7 $R1 1
      StrCpy $R1 $R1 $R6 1
      StrCmp $R7 $R3 found
      StrCpy $R2 "$R2$R7"
      StrCmp $R1 "" done loop
      
    found:
      StrCpy $R2 "$R2$R4"
      StrCmp $R1 "" done loop
      
    done:
      StrCpy $R3 $R2
      Pop $R7
      Pop $R6
      Pop $R4
      Pop $R2
      Pop $R1
      Exch $R3
  FunctionEnd
#+END_SRC
** Replace in String
This came from [[http://nsis.sourceforge.net/Another_String_Replace_%28and_Slash/BackSlash_Converter%29][here]]
#+BEGIN_SRC nsis
!macro _StrReplaceConstructor ORIGINAL_STRING TO_REPLACE REPLACE_BY VAR
  Push "${ORIGINAL_STRING}"
  Push "${TO_REPLACE}"
  Push "${REPLACE_BY}"
  Call StrRep
  Pop ${VAR}
!macroend


Function StrRep
  Exch $R4 ; $R4 = Replacement String
  Exch
  Exch $R3 ; $R3 = String to replace (needle)
  Exch 2
  Exch $R1 ; $R1 = String to do replacement in (haystack)
  Push $R2 ; Replaced haystack
  Push $R5 ; Len (needle)
  Push $R6 ; len (haystack)
  Push $R7 ; Scratch reg
  StrCpy $R2 ""
  StrLen $R5 $R3
  StrLen $R6 $R1
  loop:
    StrCpy $R7 $R1 $R5
    StrCmp $R7 $R3 found
    StrCpy $R7 $R1 1 ; - optimization can be removed if U know len needle=1
    StrCpy $R2 "$R2$R7"
    StrCpy $R1 $R1 $R6 1
    StrCmp $R1 "" done loop
  found:
    StrCpy $R2 "$R2$R4"
    StrCpy $R1 $R1 $R6 $R5
    StrCmp $R1 "" done loop
  done:
    StrCpy $R3 $R2
    Pop $R7
    Pop $R6
    Pop $R5
    Pop $R2
    Pop $R1
    Pop $R4
    Exch $R3
FunctionEnd

!define StrReplace '!insertmacro "_StrReplaceConstructor"'

#+END_SRC

** Explode
From http://nsis.sourceforge.net/Explode
#+BEGIN_SRC nsis
  !define Explode "!insertmacro Explode"
   
  !macro  Explode Length  Separator   String
      Push    `${Separator}`
      Push    `${String}`
      Call    Explode
      Pop     `${Length}`
  !macroend
  
  !define unExplode "!insertmacro unExplode"
   
  !macro  unExplode Length  Separator   String
      Push    `${Separator}`
      Push    `${String}`
      Call    un.Explode
      Pop     `${Length}`
  !macroend
   
  Function Explode
    ; Initialize variables
    Var /GLOBAL explString
    Var /GLOBAL explSeparator
    Var /GLOBAL explStrLen
    Var /GLOBAL explSepLen
    Var /GLOBAL explOffset
    Var /GLOBAL explTmp
    Var /GLOBAL explTmp2
    Var /GLOBAL explTmp3
    Var /GLOBAL explArrCount
   
    ; Get input from user
    Pop $explString
    Pop $explSeparator
   
    ; Calculates initial values
    StrLen $explStrLen $explString
    StrLen $explSepLen $explSeparator
    StrCpy $explArrCount 1
   
    ${If}   $explStrLen <= 1          ;   If we got a single character
    ${OrIf} $explSepLen > $explStrLen ;   or separator is larger than the string,
      Push    $explString             ;   then we return initial string with no change
      Push    1                       ;   and set array's length to 1
      Return
    ${EndIf}
   
    ; Set offset to the last symbol of the string
    StrCpy $explOffset $explStrLen
    IntOp  $explOffset $explOffset - 1
   
    ; Clear temp string to exclude the possibility of appearance of occasional data
    StrCpy $explTmp   ""
    StrCpy $explTmp2  ""
    StrCpy $explTmp3  ""
   
    ; Loop until the offset becomes negative
    ${Do}
      ;   If offset becomes negative, it is time to leave the function
      ${IfThen} $explOffset == -1 ${|} ${ExitDo} ${|}
      
      ;   Remove everything before and after the searched part ("TempStr")
      StrCpy $explTmp $explString $explSepLen $explOffset
      
      ${If} $explTmp == $explSeparator
          ;   Calculating offset to start copy from
          IntOp   $explTmp2 $explOffset + $explSepLen ;   Offset equals to the current offset plus length of separator
          StrCpy  $explTmp3 $explString "" $explTmp2
          
          Push    $explTmp3                           ;   Throwing array item to the stack
          IntOp   $explArrCount $explArrCount + 1     ;   Increasing array's counter
          
          StrCpy  $explString $explString $explOffset 0   ;   Cutting all characters beginning with the separator entry
          StrLen  $explStrLen $explString
      ${EndIf}
   
      ${If} $explOffset = 0                       ;   If the beginning of the line met and there is no separator,
                                                  ;   copying the rest of the string
          ${If} $explSeparator == ""              ;   Fix for the empty separator
              IntOp   $explArrCount   $explArrCount - 1
          ${Else}
              Push    $explString
          ${EndIf}
      ${EndIf}
   
      IntOp   $explOffset $explOffset - 1
    ${Loop}
   
    Push $explArrCount
  FunctionEnd
  Function un.Explode
    ; Initialize variables
    ; Get input from user
    Pop $explString
    Pop $explSeparator
   
    ; Calculates initial values
    StrLen $explStrLen $explString
    StrLen $explSepLen $explSeparator
    StrCpy $explArrCount 1
   
    ${If}   $explStrLen <= 1          ;   If we got a single character
    ${OrIf} $explSepLen > $explStrLen ;   or separator is larger than the string,
      Push    $explString             ;   then we return initial string with no change
      Push    1                       ;   and set array's length to 1
      Return
    ${EndIf}
   
    ; Set offset to the last symbol of the string
    StrCpy $explOffset $explStrLen
    IntOp  $explOffset $explOffset - 1
   
    ; Clear temp string to exclude the possibility of appearance of occasional data
    StrCpy $explTmp   ""
    StrCpy $explTmp2  ""
    StrCpy $explTmp3  ""
   
    ; Loop until the offset becomes negative
    ${Do}
      ;   If offset becomes negative, it is time to leave the function
      ${IfThen} $explOffset == -1 ${|} ${ExitDo} ${|}
   
      ;   Remove everything before and after the searched part ("TempStr")
      StrCpy $explTmp $explString $explSepLen $explOffset
   
      ${If} $explTmp == $explSeparator
          ;   Calculating offset to start copy from
          IntOp   $explTmp2 $explOffset + $explSepLen ;   Offset equals to the current offset plus length of separator
          StrCpy  $explTmp3 $explString "" $explTmp2
   
          Push    $explTmp3                           ;   Throwing array item to the stack
          IntOp   $explArrCount $explArrCount + 1     ;   Increasing array's counter
   
          StrCpy  $explString $explString $explOffset 0   ;   Cutting all characters beginning with the separator entry
          StrLen  $explStrLen $explString
      ${EndIf}
   
      ${If} $explOffset = 0                       ;   If the beginning of the line met and there is no separator,
                                                  ;   copying the rest of the string
          ${If} $explSeparator == ""              ;   Fix for the empty separator
              IntOp   $explArrCount   $explArrCount - 1
          ${Else}
              Push    $explString
          ${EndIf}
      ${EndIf}
   
      IntOp   $explOffset $explOffset - 1
    ${Loop}
   
    Push $explArrCount
  FunctionEnd
#+END_SRC
* Functions
** Callback Functions
*** Initialization Function
#+BEGIN_SRC nsis
  Function .onInit
    ClearErrors
  FunctionEnd  
#+END_SRC
*** Exit Function
#+BEGIN_SRC nsis
  Function .onGUIEnd
    ClearErrors
  FunctionEnd
  
#+END_SRC
** Convert File Name Function
This converts USB:/ and EXEDIR:/ to the appropriate values
#+BEGIN_SRC nsis
  Function ConvertToFile
    ;; $0= File
    ;; $1 = Temp
    ;; $R0 = File with backslashes.
    Push $0
    Exch
    Pop $0
    Push $1
    Push $R0
    ${StrSlash} "$0" "/"
    StrCpy $1 $R0 5
    StrCmp "$1" "USB:\" home_usb home_exe
    home_usb:
    home_exe:
      StrCpy $1 $R0 8
      StrCmp "$1" "EXEDIR:\" 0 end
      StrCpy $R0 $R0 "" 8
      StrCpy $R0 "$EXEDIR\$R0"
    end:
      Push $R0
      Exch
      Pop $R0
      Exch
      Pop $1
      Exch
      Pop $0
  FunctionEnd
  
  !macro ConvertToFile V F
    Push ${F}
    Call ConvertToFile
    Pop ${V}
  !macroend
  
  !define ConvertToFile `!insertmacro ConvertToFile`
  
  Function ConvertToAlias
    ;; $0= File
    ;; $1 = Temp
    ;; $2 = Temp
    ;; $3 = Temp
    ;; $R0 = File with backslashes.
    Push $0
    Exch
    Pop $0
    Push $1
    Push $2
    Push $3
    Push $R0
    ${StrSlash} "$0" "/"
    GetFullPathName $1 "$EXEDIR"
    StrLen $2 $1
    StrCpy $3 $R0 $2
    StrCmp $1 $3 replace_exedir
    GetFullPathName /SHORT $1 "$EXEDIR"
    StrLen $2 $1
    StrCpy $3 $R0 $2
    StrCmp $1 $3 replace_exedir
    Goto end
    replace_exedir:
      StrCpy $R0 $R0 "" $2
      StrCpy $R0 "EXEDIR:$R0" 
    end:
      Push $R0
      Exch
      Pop $R0
      Exch
      Pop $3
      Exch
      Pop $2
      Exch
      Pop $1
      Exch
      Pop $0 
  FunctionEnd
  
  !macro ConvertToAlias V F
    Push ${F}
    Call ConvertToAlias
    Pop ${V}
  !macroend
  
  !define ConvertToAlias `!insertmacro ConvertToAlias`
#+END_SRC

* Pages
** Behavior
*** Dialog Definitions
#+BEGIN_SRC nsis
  ; ========================================================
  ; This file was generated by NSISDialogDesigner 0.9.16.0
  ; http://coolsoft.altervista.org/nsisdialogdesigner
  ; ========================================================
  
  ; handle variables
  Var hCtl_behavior
  Var hCtl_behavior_GroupBox1
  Var hCtl_behavior_newFrame
  Var hCtl_behavior_Debug
  Var hCtl_behavior_Label2
  Var hCtl_behavior_Daemon
  Var hCtl_behavior_Label1
  Var hCtl_behavior_StartupScript
  Var hCtl_behavior_DefaultVersion
  Var hCtl_behavior_Home_Txt
  Var hCtl_behavior_Home_Btn
  Var hCtl_behavior_Label3
  Var hCtl_behavior_ZipBin
  Var hCtl_behavior_Clean
  Var hCtl_behavior_GroupBox2
  Var hCtl_behavior_editWith
  Var hCtl_behavior_orgProtocol
  Var hCtl_behavior_LiberKey
  
  
  ; dialog create function
  Function fnc_behavior_Create
    
    ; === behavior (type: Dialog) ===
    nsDialogs::Create 1018
    Pop $hCtl_behavior
    ${If} $hCtl_behavior == error
      Abort
    ${EndIf}
    !insertmacro MUI_HEADER_TEXT "EmacsPortable.App Behavior" "This allows the user to change the startup options, home directory, and what EmacsPortable.App integrates with."
    
    ; === Label1 (type: Label) ===
    ${NSD_CreateLabel} 13u 19u 54u 13u "Default Version"
    Pop $hCtl_behavior_Label1
    
    ; === DefaultVersion (type: DropList) ===
    ${NSD_CreateDropListSorted} 70u 17u 51u 12u ""
    Pop $hCtl_behavior_DefaultVersion
    SetCtlColors $hCtl_behavior_DefaultVersion 0x000000 0xFFFFFF
  
    ReadIniStr $3 "$EXEDIR\Data\ini\EmacsPortableApp.ini" "EmacsPortableApp" "Version"
    ClearErrors
    StrCpy $4 ""
    
    FindFirst $0 $1 $EXEDIR\App\emacs-*.*
    loop_emacs:
      StrCmp $1 "" done_emacs
      StrCpy $1 $1 "" 6
      StrCpy $2 $1
      StrCmp $2 $3 0 +2
      StrCpy $4 $2
      ${NSD_CB_AddString} $hCtl_behavior_DefaultVersion $1
      FindNext $0 $1
      Goto loop_emacs
    done_emacs:
      FindClose $0
      StrCmp $4 "" 0 +2
      StrCpy $4 $2
      ${NSD_CB_SelectString} $hCtl_behavior_DefaultVersion $4
      
      ; === Label2 (type: Label) ===
      ${NSD_CreateLabel} 134u 19u 52u 13u "Startup Script"
      Pop $hCtl_behavior_Label2
      
      ; === StartupScript (type: DropList) ===
      ${NSD_CreateDropListSorted} 190u 17u 94u 12u ""
      Pop $hCtl_behavior_StartupScript
      SetCtlColors $hCtl_behavior_StartupScript 0x000000 0xFFFFFF
  
      ReadIniStr $3 "$EXEDIR\Data\ini\EmacsPortableApp.ini" "EmacsPortableApp" "Startup"
      ClearErrors
      StrCpy $4 ""
      
      FindFirst $0 $1 $EXEDIR\Data\start\*.*
    loop_start:
      StrCmp $1 "" done_start
      StrCmp $1 "shared" next_start
      StrCmp $1 "system" next_start
      StrCmp $1 "user" next_start
      StrCmp $1 "." next_start
      StrCmp $1 ".." next_start
      StrCpy $2 $1
      StrCmp $2 $3 0 +2
      StrCpy $4 $2
      ${NSD_CB_AddString} $hCtl_behavior_StartupScript $1
    next_start:
      FindNext $0 $1
      Goto loop_start
    done_start:
      FindClose $0
      StrCmp $4 "" 0 +2
      StrCpy $4 $2
      ${NSD_CB_SelectString} $hCtl_behavior_StartupScript $4

      ; === GroupBox1 (type: GroupBox) ===
      ${NSD_CreateGroupBox} 8u 7u 280u 77u "EmacsPortable.App Launching Options"
      Pop $hCtl_behavior_GroupBox1
      
      ; === newFrame (type: Checkbox) ===
      ${NSD_CreateCheckbox} 105u 34u 93u 14u "New Frame on file open"
      Pop $hCtl_behavior_newFrame
      ${SetUnCheck} $hCtl_behavior_newFrame "NewFrame"
      
      ; === Debug (type: Checkbox) ===
      ${NSD_CreateCheckbox} 200u 34u 84u 14u "Debug Startup (gdb)"
      Pop $hCtl_behavior_Debug
      ${SetUnCheck} $hCtl_behavior_Debug "Debug"
      
      ; === Daemon (type: Checkbox) ===
      ${NSD_CreateCheckbox} 13u 34u 88u 14u "Use Pseudo-Daemon"
      Pop $hCtl_behavior_Daemon
      ${SetCheck} $hCtl_behavior_Daemon "Daemon"
      
      ; === Home_Txt (type: Text) ===
      ${NSD_CreateText} 70u 65u 192u 11u ""
      Pop $hCtl_behavior_Home_Txt
      ${SetDir} $hCtl_behavior_Home_Txt "Home" "EXEDIR:/Data/Home"
  
      ; === Label3 (type: Label) ===
      ${NSD_CreateLabel} 13u 65u 54u 13u "Home Directory"
      Pop $hCtl_behavior_Label3
      
      ; === Home_Btn (type: Button) ===
      ${NSD_CreateButton} 264u 65u 20u 11u "..."
      Pop $hCtl_behavior_Home_Btn
      ${NSD_OnClick} $hCtl_behavior_Home_Btn fnc_hCtl_behavior_Home_Click
      
      ; === ZipBin (type: Checkbox) ===
      ${NSD_CreateCheckbox} 12u 48u 151u 14u "(Un)Zip Binaries && Run from %TEMP%"
      Pop $hCtl_behavior_ZipBin
      ${SetUnCheck} $hCtl_behavior_ZipBin "Zip"
      
      ; === Clean (type: Checkbox) ===
      ${NSD_CreateCheckbox} 167u 48u 117u 14u "Clean Residual Files (Stealth)"
      Pop $hCtl_behavior_Clean
      ${SetCheck} $hCtl_behavior_Clean "Clean"
      
      
      ; === GroupBox2 (type: GroupBox) ===
      ${NSD_CreateGroupBox} 8u 87u 280u 26u "Integration Options"
      Pop $hCtl_behavior_GroupBox2
      
      ; === editWith (type: Checkbox) ===
      ${NSD_CreateCheckbox} 12u 97u 89u 14u "Right-Click $\"Edit With$\""
      Pop $hCtl_behavior_editWith
      ${SetCheck} $hCtl_behavior_editWith "RightEdit"
      
      ; === orgProtocol (type: Checkbox) ===
      ${NSD_CreateCheckbox} 105u 97u 58u 14u "org-protocol"
      Pop $hCtl_behavior_orgProtocol
      ${SetCheck} $hCtl_behavior_orgProtocol "OrgProtocol"
      
      ; === LiberKey (type: Checkbox) ===
      ${NSD_CreateCheckbox} 167u 97u 47u 14u "LiberKey"
      Pop $hCtl_behavior_LiberKey
      ${SetUnCheck} $hCtl_behavior_LiberKey "LiberKey"
      
  FunctionEnd
  
  
  ; dialog show function
  Function fnc_behavior_Show
    Call fnc_behavior_Create
    nsDialogs::Show $hCtl_behavior
  FunctionEnd
  
  
  ; onClick handler for DirRequest Button $hCtl_behavior_Home_Btn
  Function fnc_hCtl_behavior_Home_Click
    Pop $R0
    ${If} $R0 == $hCtl_behavior_Home_Btn
      ${NSD_GetText} $hCtl_behavior_Home_Txt $R0
      ${ConvertToFile} $R0 $R0
      nsDialogs::SelectFolderDialog /NOUNLOAD "" "$R0"
      Pop $R0
      ${If} "$R0" != "error"
        ${ConvertToAlias} $R0 $R0
        ${NSD_SetText} $hCtl_behavior_Home_Txt "$R0"
      ${EndIf}
    ${EndIf}
  FunctionEnd
  
#+END_SRC

*** Validation Function
#+BEGIN_SRC nsis
  Function fnc_behavior_Validate
    ## Save Data.
    ${WriteCheck} $hCtl_behavior_newFrame "NewFrame"
    ${WriteCheck} $hCtl_behavior_Debug "Debug"
    ${WriteCheck} $hCtl_behavior_Daemon "Daemon"
    ${WriteCheck} $hCtl_behavior_ZipBin "Zip"
    ${WriteCheck} $hCtl_behavior_Clean "Clean"
    ${WriteCheck} $hCtl_behavior_editWith "RightEdit"
    ${WriteCheck} $hCtl_behavior_orgProtocol "OrgProtocol"
    ${WriteCheck} $hCtl_behavior_LiberKey "LiberKey"
    
    ${WriteText} $hCtl_behavior_Home_Txt "Home"

    ${WriteCB} $hCtl_behavior_DefaultVersion "Version"
    ${WriteCB} $hCtl_behavior_StartupScript "Startup"
  FunctionEnd
  
#+END_SRC

** Visuals
*** Dialog Definitions
#+BEGIN_SRC nsis
  ; ========================================================
  ; This file was generated by NSISDialogDesigner 0.9.16.0
  ; http://coolsoft.altervista.org/nsisdialogdesigner
  ; ========================================================
  
  ; handle variables
  Var hCtl_visuals
  Var hCtl_visuals_GroupBox1
  Var hCtl_visuals_FontName
  Var hCtl_visuals_Label1
  Var hCtl_visuals_FontLabel
  Var hCtl_visuals_Label2
  Var hCtl_visuals_Label3
  Var hCtl_visuals_fg
  Var hCtl_visuals_bg
  Var hCtl_visuals_FontSize
  Var hCtl_visuals_sync
  Var hCtl_visuals_GroupBox2
  Var hCtl_visuals_Label5
  Var hCtl_visuals_Label7
  Var hCtl_visuals_Label4
  Var hCtl_visuals_Label6
  Var hCtl_visuals_gh
  Var hCtl_visuals_gw
  Var hCtl_visuals_gx
  Var hCtl_visuals_gy
  Var hCtl_visuals_GroupBox3
  Var hCtl_visuals_mn
  Var hCtl_visuals_max
  Var hCtl_visuals_mw
  Var hCtl_visuals_mh
  Var hCtl_visuals_mnf
  
  
  ; dialog create function
  Function fnc_visuals_Create
    
    ; === visuals (type: Dialog) ===
    nsDialogs::Create 1018
    Pop $hCtl_visuals
    ${If} $hCtl_visuals == error
      Abort
    ${EndIf}
    !insertmacro MUI_HEADER_TEXT "EmacsPortable.App Visual Options" "Sets the initial foreground, background, font, and positioning options of EmacsPortable.App"
    
    ; === GroupBox1 (type: GroupBox) ===
    ${NSD_CreateGroupBox} 8u 7u 280u 51u "Emacs Display Options"
    Pop $hCtl_visuals_GroupBox1
    
    ; === FontName (type: ComboBox) ===
    ${NSD_CreateComboBoxSorted} 59u 17u 123u 12u ""
    Pop $hCtl_visuals_FontName
    SetCtlColors $hCtl_visuals_FontName 0x000000 0xFFFFFF
    Call SetFontOptions
    
    ${NSD_CB_SelectString} $hCtl_visuals_FontName $3
    
    ; === Label1 (type: Label) ===
    ${NSD_CreateLabel} 186u 19u 32u 13u "Size"
    Pop $hCtl_visuals_Label1
    
    ; === FontLabel (type: Label) ===
    ${NSD_CreateLabel} 12u 19u 43u 13u "Font Name:"
    Pop $hCtl_visuals_FontLabel
    
    ; === Label2 (type: Label) ===
    ${NSD_CreateLabel} 12u 32u 66u 13u "Foreground Color:"
    Pop $hCtl_visuals_Label2
    
    ; === Label3 (type: Label) ===
    ${NSD_CreateLabel} 152u 32u 66u 13u "Background Color:"
    Pop $hCtl_visuals_Label3
    
    ; === fg (type: Text) ===
    ${NSD_CreateText} 81u 30u 56u 11u ""
    Pop $hCtl_visuals_fg
    ${SetText} $hCtl_visuals_fg "Foreground" ""
    
    ; === bg (type: Text) ===
    ${NSD_CreateText} 222u 30u 62u 11u "" 
    Pop $hCtl_visuals_bg
    ${SetText} $hCtl_visuals_bg "Background" ""
    
    ; === FontSize (type: Number) ===
    ${NSD_CreateNumber} 222u 17u 62u 11u ""
    Pop $hCtl_visuals_FontSize
    ${SetText} $hCtl_visuals_FontSize "FontSize" "12"
    
    ; === sync (type: Link) ===
    ${NSD_CreateLink} 12u 43u 272u 13u "Sync EmacsPortable.App's current colors and fonts with the startup options"
    Pop $hCtl_visuals_sync
    ${NSD_OnClick} $hCtl_visuals_sync SyncColor
    
    ; === GroupBox2 (type: GroupBox) ===
    ${NSD_CreateGroupBox} 8u 61u 152u 61u "Emacs Frame/Window Geometry"
    Pop $hCtl_visuals_GroupBox2
    
    ReadIniStr $R0 "$EXEDIR\Data\ini\EmacsPortableApp.ini" "EmacsPortableApp" "Geometry"
    
    StrCpy $R2 ""
    StrCpy $R3 ""
    StrCpy $R4 ""
    StrCpy $R5 ""
    
    ${Explode} $R1 "x" "$R0"
    
    ${If} $R1 == 2
      Pop $R2
      Pop $R3
      ${Explode} $R4 "+" $R3
      ${If} $R4 == 3
        Pop $R3
        Pop $R4
        Pop $R5
      ${Else}
        StrCpy $R4 ""
      ${EndIf}
    ${Else}
      ${Explode} $R1 "X" "$R0"
      ${If} $R1 == 2
        Pop $R2
        Pop $R3
        ${Explode} $R4 "+" $R3
        ${If} $R4 == 3
          Pop $R5
          Pop $R3
          Pop $R4
        ${Else}
          StrCpy $R4 ""
        ${EndIf}
      ${EndIf}
    ${EndIf}
    
    ; === Label5 (type: Label) ===
    ${NSD_CreateLabel} 12u 83u 107u 13u "Initial Frame Height (rows)"
    Pop $hCtl_visuals_Label5
    
    ; === Label7 (type: Label) ===
    ${NSD_CreateLabel} 12u 109u 107u 13u "Down offset (Y),top left corner "
    Pop $hCtl_visuals_Label7
    
    ; === Label4 (type: Label) ===
    ${NSD_CreateLabel} 12u 70u 107u 13u "Initial Frame Width (characters)"
    Pop $hCtl_visuals_Label4
    
    ; === Label6 (type: Label) ===
    ${NSD_CreateLabel} 12u 96u 107u 13u "Right offset (X),top left corner "
    Pop $hCtl_visuals_Label6
    
    ; === gh (type: Number) ===
    ${NSD_CreateNumber} 123u 81u 32u 11u ""
    Pop $hCtl_visuals_gh
    ${NSD_SetText} $hCtl_visuals_gh $R3
    
    ; === gw (type: Number) ===
    ${NSD_CreateNumber} 123u 68u 32u 11u ""
    Pop $hCtl_visuals_gw
    ${NSD_SetText} $hCtl_visuals_gw $R2
    
    ; === gx (type: Number) ===
    ${NSD_CreateNumber} 123u 94u 32u 11u ""
    Pop $hCtl_visuals_gx
    ${NSD_SetText} $hCtl_visuals_gx $R4
    
    ; === gy (type: Number) ===
    ${NSD_CreateNumber} 123u 107u 32u 11u ""
    Pop $hCtl_visuals_gy
    ${NSD_SetText} $hCtl_visuals_gy $R5
    
    ; === GroupBox3 (type: GroupBox) ===
    ${NSD_CreateGroupBox} 164u 61u 123u 61u "Maximization Options"
    Pop $hCtl_visuals_GroupBox3
    
    ; === mn (type: RadioButton) ===
    ${NSD_CreateRadioButton} 168u 70u 39u 14u "None"
    Pop $hCtl_visuals_mn
  
    ReadIniStr $R0 "$EXEDIR\Data\ini\EmacsPortableApp.ini" "EmacsPortableApp" "Max"
    ${If} $R0 == "0"
    ${OrIf} ${Errors}
      ClearErrors
      ReadIniStr $R0 "$EXEDIR\Data\ini\EmacsPortableApp.ini" "EmacsPortableApp" "Fullwidth"
      ${If} $R0 == "0"
      ${OrIf} ${Errors}
        ClearErrors
        ReadIniStr $R0 "$EXEDIR\Data\ini\EmacsPortableApp.ini" "EmacsPortableApp" "Fullheight"
        ${If} $R0 == "0"
        ${OrIf} ${Errors}
          ClearErrors
          ${NSD_Check} $hCtl_visuals_mn 
        ${EndIf}
      ${EndIf}
    ${EndIf}
    ClearErrors
    
    ; === mm (type: RadioButton) ===
    ${NSD_CreateRadioButton} 222u 70u 47u 14u "Maximize"
    Pop $hCtl_visuals_max
    ${SetUnCheck} $hCtl_visuals_max "Max"
    
    ; === mw (type: RadioButton) ===
    ${NSD_CreateRadioButton} 168u 87u 51u 14u "Full Width"
    Pop $hCtl_visuals_mw
    ${SetUnCheck} $hCtl_visuals_mw "Fullwidth"
    
    ; === mh (type: RadioButton) ===
    ${NSD_CreateRadioButton} 223u 87u 51u 14u "Full Height"
    Pop $hCtl_visuals_mh
    ${SetUnCheck} $hCtl_visuals_mh "Fullheight"
    
    ; === mnf (type: Checkbox) ===
    ${NSD_CreateCheckbox} 168u 104u 100u 14u "Apply to New Frames"
    Pop $hCtl_visuals_mnf
    ${SetUnCheck} $hCtl_visuals_mnf "MaxApplyNew"
    ClearErrors
    
  FunctionEnd
  
  ; dialog show function
  Function fnc_visuals_Show
    Call fnc_visuals_Create
    nsDialogs::Show $hCtl_visuals
  FunctionEnd
  
#+END_SRC

*** Support Functions
#+BEGIN_SRC nsis
  Function SetFontOptions
    ReadIniStr $3 "$EXEDIR\Data\ini\EmacsPortableApp.ini" "EmacsPortableApp" "Font"
    ClearErrors
    StrCpy $4 $3
    IfFileExists "$EXEDIR\App\ini\fonts.ini" 0 no_fonts
    EnumIni::Section "$EXEDIR\App\ini\fonts.ini" "fonts1"
    pop $R0
    StrCmp $R0 "error" no_fonts
    loop_fonts:
      IntCmp $R0 "0" no_fonts no_fonts 0
      Pop $R1
      StrCmp "$3" "$R1" 0 +2
      StrCpy "$3" ""
      ${NSD_CB_AddString} $hCtl_visuals_FontName $R1
    no_install:
      IntOp $R0 $R0 - 1
      Goto loop_fonts
    no_fonts:
      StrCmp "$3" "" clear
      ${NSD_CB_AddString} $hCtl_visuals_FontName $3
    clear:
      ${NSD_CB_SelectString} $hCtl_visuals_FontName $4
      ClearErrors
  FunctionEnd
  
  Function SyncColor
    ExecWait `"$EXEDIR\EmacsPortableApp.exe" /COLORSYNC`
    ${SetText} $hCtl_visuals_FontSize "FontSize" "12"
    ${SetText} $hCtl_visuals_bg "Background" ""
    ${SetText} $hCtl_visuals_fg "Foreground" ""
    SendMessage $hCtl_visuals_FontName ${CB_RESETCONTENT} $0 $0
    Call SetFontOptions
  FunctionEnd
  
#+END_SRC

*** Validation Function
#+BEGIN_SRC nsis
  Function fnc_visuals_Validate
    ${WriteCheck} $hCtl_visuals_max "Max"
    ${WriteCheck} $hCtl_visuals_mw "Fullwidth"
    ${WriteCheck} $hCtl_visuals_mh "Fullheight"
    ${WriteCheck} $hCtl_visuals_mnf "MaxApplyNew"
    
    ${WriteText} $hCtl_visuals_FontSize "FontSize"
    ${WriteText} $hCtl_visuals_bg "Background"
    ${WriteText} $hCtl_visuals_fg "Foreground"
  
    ${WriteCB} $hCtl_visuals_FontName "Font"
    
    ${NSD_GetText} $hCtl_visuals_gh $R3
    ${NSD_GetText} $hCtl_visuals_gw $R2
    ${NSD_GetText} $hCtl_visuals_gx $R4
    ${NSD_GetText} $hCtl_visuals_gy $R5
    StrCpy $R0 ""
    ${If} $R2 != ""
    ${AndIf} $R3 != ""
      StrCpy $R0 "$R2x$R3"
      ${If} $R4 != ""
      ${AndIf} $R5 != ""
        StrCpy $R0 "$R0+$R4+$R5"
      ${EndIf}
    ${EndIf}
    WriteIniStr "$EXEDIR\Data\ini\EmacsPortableApp.ini" "EmacsPortableApp" "Geometry" $R0
  FunctionEnd
  
#+END_SRC

* Obligatory Section
#+BEGIN_SRC nsis
  Section "Components" 
    ;Get Install Options dialog user input
      ClearErrors
  SectionEnd
#+END_SRC  


