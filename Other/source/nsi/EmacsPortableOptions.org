#+TITLE: EmacsPortable Startup Options
#+AUTHOR: Matthew L. Fidler
#+PROPERTY: tangle EmacsPortableOptions.nsi
* Introduction
This provides an interface to the Emacs Startup options
* Header
** Compression and other options
#+BEGIN_SRC nsis
  CRCCheck On
  RequestExecutionLevel user
  ; Best Compression
  SetCompress Auto
  SetCompressor /SOLID lzma
  SetCompressorDictSize 32
  SetDatablockOptimize On
#+END_SRC
** Definitions and Variables
#+BEGIN_SRC nsis
  !define TEMP1 $R0 ;Temp variable
  
#+END_SRC
** Include files
#+BEGIN_SRC nsis
  !include "MUI2.nsh"
  !include "LogicLib.nsh"
  !include "CommCtrl.nsh"
  !include "FileFunc.nsh"
  !include "emacsproxy.nsh"
  !include "setupEmacsData.nsh"
#+END_SRC
** Name,Branding and Output file
#+BEGIN_SRC nsis
  Name "EmacsPortable.App Options"
  OutFile "..\..\..\EmacsOptions.exe"
  BrandingText "PortableEmacs.App"
  
  InstallDir "$EXEDIR"
#+END_SRC
** Modern User Interface Options
#+BEGIN_SRC nsis
  !define MUI_ICON "..\img\ico\preferences_system.ico"
  #!define MUI_UNICON
  !define MUI_HEADERIMAGE
  
  !define MUI_HEADERIMAGE_BITMAP "..\img\headerimage-options.bmp" ; 150x57 pixels
  !define MUI_HEADERIMAGE_UNBITMAP "..\img\headerimage-options.bmp" ; 150x57 pixels
  
  !define MUI_WELCOMEFINISHPAGE_BITMAP "..\img\welcome-options.bmp" ;164x314 pixels
  !define MUI_UNWELCOMEFINISHPAGE_BITMAP "..\img\welcome-options.bmp" ;164x314 pixels
  
  !define MUI_ABORTWARNING
  !define MUI_UNABORTWARNING
  !define MUI_PAGE_HEADER_TEXT "EmacsPortable.app"
  !define MUI_PAGE_HEADER_SUBTEXT "Emacs on the Go"
  
  !define MUI_COMPONENTSPAGE_SMALLDESC
  !define MUI_HEADERIMAGE_RIGHT
#+END_SRC

** NSIS Pages
#+BEGIN_SRC nsis
  ;Order of pages
  Page custom fnc_behavior_Show fnc_behavior_Validate
  !insertmacro MUI_PAGE_INSTFILES
  !insertmacro MUI_PAGE_FINISH
  !insertmacro MUI_LANGUAGE "English"
  
#+END_SRC
* Macros
** Read/Write Macros
#+BEGIN_SRC nsis  
  !macro SetCheck VARIABLE OPT 
    ReadIniStr $R0 "$EXEDIR\Data\ini\EmacsPortableApp.ini" "EmacsPortableApp" "${OPT}"
    ${If} $R0 == "1"
      ${NSD_Check} ${VARIABLE}
    ${ElseIf} ${Errors}
      ${NSD_Check} ${VARIABLE}
    ${Else}
      ${NSD_UnCheck} ${VARIABLE}
    ${EndIf}
    ClearErrors
  !macroend
  !define SetCheck `!insertmacro SetCheck`
  
  !macro SetUnCheck VARIABLE OPT 
    ReadIniStr $R0 "$EXEDIR\Data\ini\EmacsPortableApp.ini" "EmacsPortableApp" "${OPT}"
    ${If} $R0 == "1"
      ${NSD_Check} ${VARIABLE}
    ${ElseIf} ${Errors}
      ${NSD_Check} ${VARIABLE}
    ${Else}
      ${NSD_UnCheck} ${VARIABLE}
    ${EndIf}
    ClearErrors
  !macroend
  !define SetUnCheck `!insertmacro SetUnCheck`
  
  !macro SetDir VARIABLE OPT ERR
    ReadIniStr $R0 "$EXEDIR\Data\ini\EmacsPortableApp.ini" "EmacsPortableApp" "${OPT}"
    ${If} ${Errors}
      StrCpy $R0 "${ERR}"
    ${EndIf}
    ${NSD_SetText} ${VARIABLE} $R0
    
  !macroend
  !define SetDir `!insertmacro SetDir`
  
  !macro WriteCheck VARIABLE OPT
    ${NSD_GetState} ${VARIABLE} $R0
    ${If} $R0 == ${BST_CHECKED}
      WriteIniStr "$EXEDIR\Data\ini\EmacsPortableApp.ini" "EmacsPortableApp" \
          "${OPT}" "1"
    ${Else}
      WriteIniStr "$EXEDIR\Data\ini\EmacsPortableApp.ini" "EmacsPortableApp" \
          "${OPT}" "0"
    ${EndIf}  
  !macroend
  !define WriteCheck `!insertmacro WriteCheck`
  
  !macro WriteText VARIABLE OPT
    ${NSD_GetText} ${VARIABLE} $R0
    WriteIniStr "$EXEDIR\Data\ini\EmacsPortableApp.ini" "EmacsPortableApp" \
        "${OPT}" "$R0"
  !macroEnd
  !define WriteText `!insertmacro WriteText`
  
  !macro WriteCB VARIABLE OPT
    ${NSD_CB_GetSelection} ${VARIABLE} $R0
    WriteIniStr "$EXEDIR\Data\ini\EmacsPortableApp.ini" "EmacsPortableApp" \
        "${OPT}" "$R0"
  !macroend
  !define WriteCB `!insertmacro WriteCB`
  
  
#+END_SRC
** StrSlash
#+BEGIN_SRC nsis
  ## StringSlash
  !macro _StrSlash FILENAME SLASH
    Push "${FILENAME}"
    Push "${SLASH}"
    Call StrSlash
    Pop $R0
  !macroend
  !define StrSlash `!insertmacro _StrSlash`
  ; Push $filenamestring (e.g. 'c:\this\and\that\filename.htm')
  ; Push "\"
  ; Call StrSlash
  ; Pop $R0
  ; ;Now $R0 contains 'c:/this/and/that/filename.htm'
  Function StrSlash
    Exch $R3 ; $R3 = needle ("\" or "/")
    Exch
    Exch $R1 ; $R1 = String to replacement in (haystack)
    Push $R2 ; Replaced haystack
    Push $R4 ; $R4 = not $R3 ("/" or "\")
    Push $R6
    Push $R7 ; Scratch reg
    StrCpy $R2 ""
    StrLen $R6 $R1
    StrCpy $R4 "\"
    StrCmp $R3 "/" loop
    StrCpy $R4 "/"
    
    loop:
      StrCpy $R7 $R1 1
      StrCpy $R1 $R1 $R6 1
      StrCmp $R7 $R3 found
      StrCpy $R2 "$R2$R7"
      StrCmp $R1 "" done loop
      
    found:
      StrCpy $R2 "$R2$R4"
      StrCmp $R1 "" done loop
      
    done:
      StrCpy $R3 $R2
      Pop $R7
      Pop $R6
      Pop $R4
      Pop $R2
      Pop $R1
      Exch $R3
  FunctionEnd
#+END_SRC
** Replace in String
This came from [[http://nsis.sourceforge.net/Another_String_Replace_%28and_Slash/BackSlash_Converter%29][here]]
#+BEGIN_SRC nsis
!macro _StrReplaceConstructor ORIGINAL_STRING TO_REPLACE REPLACE_BY VAR
  Push "${ORIGINAL_STRING}"
  Push "${TO_REPLACE}"
  Push "${REPLACE_BY}"
  Call StrRep
  Pop ${VAR}
!macroend


Function StrRep
  Exch $R4 ; $R4 = Replacement String
  Exch
  Exch $R3 ; $R3 = String to replace (needle)
  Exch 2
  Exch $R1 ; $R1 = String to do replacement in (haystack)
  Push $R2 ; Replaced haystack
  Push $R5 ; Len (needle)
  Push $R6 ; len (haystack)
  Push $R7 ; Scratch reg
  StrCpy $R2 ""
  StrLen $R5 $R3
  StrLen $R6 $R1
  loop:
    StrCpy $R7 $R1 $R5
    StrCmp $R7 $R3 found
    StrCpy $R7 $R1 1 ; - optimization can be removed if U know len needle=1
    StrCpy $R2 "$R2$R7"
    StrCpy $R1 $R1 $R6 1
    StrCmp $R1 "" done loop
  found:
    StrCpy $R2 "$R2$R4"
    StrCpy $R1 $R1 $R6 $R5
    StrCmp $R1 "" done loop
  done:
    StrCpy $R3 $R2
    Pop $R7
    Pop $R6
    Pop $R5
    Pop $R2
    Pop $R1
    Pop $R4
    Exch $R3
FunctionEnd

!define StrReplace '!insertmacro "_StrReplaceConstructor"'

#+END_SRC

** Explode
From http://nsis.sourceforge.net/Explode
#+BEGIN_SRC nsis
!define Explode "!insertmacro Explode"
 
!macro  Explode Length  Separator   String
    Push    `${Separator}`
    Push    `${String}`
    Call    Explode
    Pop     `${Length}`
!macroend

!define unExplode "!insertmacro unExplode"
 
!macro  unExplode Length  Separator   String
    Push    `${Separator}`
    Push    `${String}`
    Call    un.Explode
    Pop     `${Length}`
!macroend
 
Function Explode
  ; Initialize variables
  Var /GLOBAL explString
  Var /GLOBAL explSeparator
  Var /GLOBAL explStrLen
  Var /GLOBAL explSepLen
  Var /GLOBAL explOffset
  Var /GLOBAL explTmp
  Var /GLOBAL explTmp2
  Var /GLOBAL explTmp3
  Var /GLOBAL explArrCount
 
  ; Get input from user
  Pop $explString
  Pop $explSeparator
 
  ; Calculates initial values
  StrLen $explStrLen $explString
  StrLen $explSepLen $explSeparator
  StrCpy $explArrCount 1
 
  ${If}   $explStrLen <= 1          ;   If we got a single character
  ${OrIf} $explSepLen > $explStrLen ;   or separator is larger than the string,
    Push    $explString             ;   then we return initial string with no change
    Push    1                       ;   and set array's length to 1
    Return
  ${EndIf}
 
  ; Set offset to the last symbol of the string
  StrCpy $explOffset $explStrLen
  IntOp  $explOffset $explOffset - 1
 
  ; Clear temp string to exclude the possibility of appearance of occasional data
  StrCpy $explTmp   ""
  StrCpy $explTmp2  ""
  StrCpy $explTmp3  ""
 
  ; Loop until the offset becomes negative
  ${Do}
    ;   If offset becomes negative, it is time to leave the function
    ${IfThen} $explOffset == -1 ${|} ${ExitDo} ${|}
 
    ;   Remove everything before and after the searched part ("TempStr")
    StrCpy $explTmp $explString $explSepLen $explOffset
 
    ${If} $explTmp == $explSeparator
        ;   Calculating offset to start copy from
        IntOp   $explTmp2 $explOffset + $explSepLen ;   Offset equals to the current offset plus length of separator
        StrCpy  $explTmp3 $explString "" $explTmp2
 
        Push    $explTmp3                           ;   Throwing array item to the stack
        IntOp   $explArrCount $explArrCount + 1     ;   Increasing array's counter
 
        StrCpy  $explString $explString $explOffset 0   ;   Cutting all characters beginning with the separator entry
        StrLen  $explStrLen $explString
    ${EndIf}
 
    ${If} $explOffset = 0                       ;   If the beginning of the line met and there is no separator,
                                                ;   copying the rest of the string
        ${If} $explSeparator == ""              ;   Fix for the empty separator
            IntOp   $explArrCount   $explArrCount - 1
        ${Else}
            Push    $explString
        ${EndIf}
    ${EndIf}
 
    IntOp   $explOffset $explOffset - 1
  ${Loop}
 
  Push $explArrCount
FunctionEnd
Function un.Explode
  ; Initialize variables
  ; Get input from user
  Pop $explString
  Pop $explSeparator
 
  ; Calculates initial values
  StrLen $explStrLen $explString
  StrLen $explSepLen $explSeparator
  StrCpy $explArrCount 1
 
  ${If}   $explStrLen <= 1          ;   If we got a single character
  ${OrIf} $explSepLen > $explStrLen ;   or separator is larger than the string,
    Push    $explString             ;   then we return initial string with no change
    Push    1                       ;   and set array's length to 1
    Return
  ${EndIf}
 
  ; Set offset to the last symbol of the string
  StrCpy $explOffset $explStrLen
  IntOp  $explOffset $explOffset - 1
 
  ; Clear temp string to exclude the possibility of appearance of occasional data
  StrCpy $explTmp   ""
  StrCpy $explTmp2  ""
  StrCpy $explTmp3  ""
 
  ; Loop until the offset becomes negative
  ${Do}
    ;   If offset becomes negative, it is time to leave the function
    ${IfThen} $explOffset == -1 ${|} ${ExitDo} ${|}
 
    ;   Remove everything before and after the searched part ("TempStr")
    StrCpy $explTmp $explString $explSepLen $explOffset
 
    ${If} $explTmp == $explSeparator
        ;   Calculating offset to start copy from
        IntOp   $explTmp2 $explOffset + $explSepLen ;   Offset equals to the current offset plus length of separator
        StrCpy  $explTmp3 $explString "" $explTmp2
 
        Push    $explTmp3                           ;   Throwing array item to the stack
        IntOp   $explArrCount $explArrCount + 1     ;   Increasing array's counter
 
        StrCpy  $explString $explString $explOffset 0   ;   Cutting all characters beginning with the separator entry
        StrLen  $explStrLen $explString
    ${EndIf}
 
    ${If} $explOffset = 0                       ;   If the beginning of the line met and there is no separator,
                                                ;   copying the rest of the string
        ${If} $explSeparator == ""              ;   Fix for the empty separator
            IntOp   $explArrCount   $explArrCount - 1
        ${Else}
            Push    $explString
        ${EndIf}
    ${EndIf}
 
    IntOp   $explOffset $explOffset - 1
  ${Loop}
 
  Push $explArrCount
FunctionEnd
#+END_SRC
* Functions
** Callback Functions
*** Initialization Function
#+BEGIN_SRC nsis
  Function .onInit
    ClearErrors
  FunctionEnd  
#+END_SRC
*** Exit Function
#+BEGIN_SRC nsis
  Function .onGUIEnd
    ClearErrors
  FunctionEnd
  
#+END_SRC
** Convert File Name Function
This converts USB:/ and EXEDIR:/ to the appropriate values
#+BEGIN_SRC nsis
  Function ConvertToFile
    ;; $0= File
    ;; $1 = Temp
    ;; $R0 = File with backslashes.
    Push $0
    Exch
    Pop $0
    Push $1
    Push $R0
    ${StrSlash} "$0" "/"
    StrCpy $1 $R0 5
    StrCmp "$1" "USB:\" home_usb home_exe
    home_usb:
    home_exe:
      StrCpy $1 $R0 8
      StrCmp "$1" "EXEDIR:\" 0 end
      StrCpy $R0 $R0 "" 8
      StrCpy $R0 "$EXEDIR\$R0"
    end:
      Push $R0
      Exch
      Pop $R0
      Exch
      Pop $1
      Exch
      Pop $0
  FunctionEnd
  
  !macro ConvertToFile V F
    Push ${F}
    Call ConvertToFile
    Pop ${V}
  !macroend
  
  !define ConvertToFile `!insertmacro ConvertToFile`
  
  Function ConvertToAlias
    ;; $0= File
    ;; $1 = Temp
    ;; $2 = Temp
    ;; $3 = Temp
    ;; $R0 = File with backslashes.
    Push $0
    Exch
    Pop $0
    Push $1
    Push $2
    Push $3
    Push $R0
    ${StrSlash} "$0" "/"
    GetFullPathName $1 "$EXEDIR"
    StrLen $2 $1
    StrCpy $3 $R0 $2
    StrCmp $1 $3 replace_exedir
    GetFullPathName /SHORT $1 "$EXEDIR"
    StrLen $2 $1
    StrCpy $3 $R0 $2
    StrCmp $1 $3 replace_exedir
    Goto end
    replace_exedir:
      StrCpy $R0 $R0 "" $2
      StrCpy $R0 "EXEDIR:$R0" 
    end:
      Push $R0
      Exch
      Pop $R0
      Exch
      Pop $3
      Exch
      Pop $2
      Exch
      Pop $1
      Exch
      Pop $0 
  FunctionEnd
  
  !macro ConvertToAlias V F
    Push ${F}
    Call ConvertToAlias
    Pop ${V}
  !macroend
  
  !define ConvertToAlias `!insertmacro ConvertToAlias`
#+END_SRC

* Pages
** Behavior
*** Dialog Definitions
#+BEGIN_SRC nsis
  ; ========================================================
  ; This file was generated by NSISDialogDesigner 0.9.16.0
  ; http://coolsoft.altervista.org/nsisdialogdesigner
  ; ========================================================
  
  ; handle variables
  Var hCtl_behavior
  Var hCtl_behavior_GroupBox1
  Var hCtl_behavior_newFrame
  Var hCtl_behavior_Debug
  Var hCtl_behavior_Label2
  Var hCtl_behavior_Daemon
  Var hCtl_behavior_Label1
  Var hCtl_behavior_StartupScript
  Var hCtl_behavior_DefaultVersion
  Var hCtl_behavior_Home_Txt
  Var hCtl_behavior_Home_Btn
  Var hCtl_behavior_Label3
  Var hCtl_behavior_ZipBin
  Var hCtl_behavior_Clean
  Var hCtl_behavior_GroupBox2
  Var hCtl_behavior_editWith
  Var hCtl_behavior_orgProtocol
  Var hCtl_behavior_LiberKey
  
  
  ; dialog create function
  Function fnc_behavior_Create
    
    ; === behavior (type: Dialog) ===
    nsDialogs::Create 1018
    Pop $hCtl_behavior
    ${If} $hCtl_behavior == error
      Abort
    ${EndIf}
    !insertmacro MUI_HEADER_TEXT "EmacsPortable.App Behavior" "This allows the user to change the startup options, home directory, and what EmacsPortable.App integrates with."
    
    ; === Label1 (type: Label) ===
    ${NSD_CreateLabel} 13u 19u 54u 13u "Default Version"
    Pop $hCtl_behavior_Label1
    
    ; === DefaultVersion (type: DropList) ===
    ${NSD_CreateDropList} 70u 17u 51u 12u ""
    Pop $hCtl_behavior_DefaultVersion
    SetCtlColors $hCtl_behavior_DefaultVersion 0x000000 0xFFFFFF
  
    ReadIniStr $3 "$EXEDIR\Data\ini\EmacsPortableApp.ini" "EmacsPortableApp" "Version"
    ClearErrors
    StrCpy $4 ""
    
    FindFirst $0 $1 $EXEDIR\App\emacs-*.*
    loop_emacs:
      StrCmp $1 "" done_emacs
      StrCpy $1 $1 "" 6
      StrCpy $2 $1
      StrCmp $2 $3 0 +2
      StrCpy $4 $2
      ${NSD_CB_AddString} $hCtl_behavior_DefaultVersion $1
      FindNext $0 $1
      Goto loop_emacs
    done_emacs:
      FindClose $0
      StrCmp $4 "" 0 +2
      StrCpy $4 $2
      ${NSD_CB_SelectString} $hCtl_behavior_DefaultVersion $4
      
      ; === Label2 (type: Label) ===
      ${NSD_CreateLabel} 134u 19u 52u 13u "Startup Script"
      Pop $hCtl_behavior_Label2
      
      ; === StartupScript (type: DropList) ===
      ${NSD_CreateDropList} 190u 17u 94u 12u ""
      Pop $hCtl_behavior_StartupScript
      SetCtlColors $hCtl_behavior_StartupScript 0x000000 0xFFFFFF
  
      ReadIniStr $3 "$EXEDIR\Data\ini\EmacsPortableApp.ini" "EmacsPortableApp" "Startup"
      ClearErrors
      StrCpy $4 ""
      
      FindFirst $0 $1 $EXEDIR\Data\start\*.*
    loop_start:
      StrCmp $1 "" done_start
      StrCmp $1 "shared" next_start
      StrCmp $1 "system" next_start
      StrCmp $1 "user" next_start
      StrCmp $1 "." next_start
      StrCmp $1 ".." next_start
      StrCpy $2 $1
      StrCmp $2 $3 0 +2
      StrCpy $4 $2
      ${NSD_CB_AddString} $hCtl_behavior_StartupScript $1
    next_start:
      FindNext $0 $1
      Goto loop_start
    done_start:
      FindClose $0
      StrCmp $4 "" 0 +2
      StrCpy $4 $2
      ${NSD_CB_SelectString} $hCtl_behavior_StartupScript $4
      
      
      
      ; === GroupBox1 (type: GroupBox) ===
      ${NSD_CreateGroupBox} 8u 7u 280u 77u "EmacsPortable.App Launching Options"
      Pop $hCtl_behavior_GroupBox1
      
      ; === newFrame (type: Checkbox) ===
      ${NSD_CreateCheckbox} 105u 34u 93u 14u "New Frame on file open"
      Pop $hCtl_behavior_newFrame
      ${SetUnCheck} $hCtl_behavior_newFrame "NewFrame"
      
      ; === Debug (type: Checkbox) ===
      ${NSD_CreateCheckbox} 200u 34u 84u 14u "Debug Startup (gdb)"
      Pop $hCtl_behavior_Debug
      ${SetUnCheck} $hCtl_behavior_Debug "Debug"
      
      ; === Daemon (type: Checkbox) ===
      ${NSD_CreateCheckbox} 13u 34u 88u 14u "Use Pseudo-Daemon"
      Pop $hCtl_behavior_Daemon
      ${SetCheck} $hCtl_behavior_Daemon "Daemon"
      
      ; === Home_Txt (type: Text) ===
      ${NSD_CreateText} 70u 65u 192u 11u ""
      Pop $hCtl_behavior_Home_Txt
      ${SetDir} $hCtl_behavior_Home_Txt "Home" "EXEDIR:/Data/Home"
  
      ; === Label3 (type: Label) ===
      ${NSD_CreateLabel} 13u 65u 54u 13u "Home Directory"
      Pop $hCtl_behavior_Label3
      
      ; === Home_Btn (type: Button) ===
      ${NSD_CreateButton} 264u 65u 20u 11u "..."
      Pop $hCtl_behavior_Home_Btn
      ${NSD_OnClick} $hCtl_behavior_Home_Btn fnc_hCtl_behavior_Home_Click
      
      ; === ZipBin (type: Checkbox) ===
      ${NSD_CreateCheckbox} 12u 48u 151u 14u "(Un)Zip Binaries && Run from %TEMP%"
      Pop $hCtl_behavior_ZipBin
      ${SetUnCheck} $hCtl_behavior_ZipBin "Zip"
      
      ; === Clean (type: Checkbox) ===
      ${NSD_CreateCheckbox} 167u 48u 117u 14u "Clean Residual Files (Stealth)"
      Pop $hCtl_behavior_Clean
      ${SetCheck} $hCtl_behavior_Clean "Clean"
      
      
      ; === GroupBox2 (type: GroupBox) ===
      ${NSD_CreateGroupBox} 8u 87u 280u 26u "Integration Options"
      Pop $hCtl_behavior_GroupBox2
      
      ; === editWith (type: Checkbox) ===
      ${NSD_CreateCheckbox} 12u 97u 89u 14u "Right-Click $\"Edit With$\""
      Pop $hCtl_behavior_editWith
      ${SetCheck} $hCtl_behavior_editWith "RightEdit"
      
      ; === orgProtocol (type: Checkbox) ===
      ${NSD_CreateCheckbox} 105u 97u 58u 14u "org-protocol"
      Pop $hCtl_behavior_orgProtocol
      ${SetCheck} $hCtl_behavior_orgProtocol "OrgProtocol"
      
      ; === LiberKey (type: Checkbox) ===
      ${NSD_CreateCheckbox} 167u 97u 47u 14u "LiberKey"
      Pop $hCtl_behavior_LiberKey
      ${SetUnCheck} $hCtl_behavior_LiberKey "LiberKey"
      
  FunctionEnd
  
  
  ; dialog show function
  Function fnc_behavior_Show
    Call fnc_behavior_Create
    nsDialogs::Show $hCtl_behavior
  FunctionEnd
  
  
  ; onClick handler for DirRequest Button $hCtl_behavior_Home_Btn
  Function fnc_hCtl_behavior_Home_Click
    Pop $R0
    ${If} $R0 == $hCtl_behavior_Home_Btn
      ${NSD_GetText} $hCtl_behavior_Home_Txt $R0
      ${ConvertToFile} $R0 $R0
      nsDialogs::SelectFolderDialog /NOUNLOAD "" "$R0"
      Pop $R0
      ${If} "$R0" != "error"
        ${ConvertToAlias} $R0 $R0
        ${NSD_SetText} $hCtl_behavior_Home_Txt "$R0"
      ${EndIf}
    ${EndIf}
  FunctionEnd
  
#+END_SRC

*** Validation Function
#+BEGIN_SRC nsis
  Function fnc_behavior_Validate
    ## Save Data.
    ${WriteCheck} $hCtl_behavior_newFrame "NewFrame"
    ${WriteCheck} $hCtl_behavior_Debug "Debug"
    ${WriteCheck} $hCtl_behavior_Daemon "Daemon"
    ${WriteCheck} $hCtl_behavior_ZipBin "Zip"
    ${WriteCheck} $hCtl_behavior_Clean "Clean"
    ${WriteCheck} $hCtl_behavior_editWith "RightEdit"
    ${WriteCheck} $hCtl_behavior_orgProtocol "OrgProtocol"
    ${WriteCheck} $hCtl_behavior_LiberKey "LiberKey"
    
    ${WriteText} $hCtl_behavior_Home_Txt "Home"

    ${WriteCB} $hCtl_behavior_DefaultVersion "Version"
    ${WriteCB} $hCtl_behavior_StartupScript "Startup"
  FunctionEnd
  
#+END_SRC

* Obligatory Section
#+BEGIN_SRC nsis
  Section "Components" 
    ;Get Install Options dialog user input
      ClearErrors
  SectionEnd
#+END_SRC  


