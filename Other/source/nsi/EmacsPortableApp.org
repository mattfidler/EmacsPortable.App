#+TITLE: EmacsPortable.App
#+AUTHOR: Matthew L. Fidler
#+PROPERTY: tangle EmacsPortableApp.nsi
* Launcher Properties
** Setup Options
I want:
 - user level execution
 - CRC check
#+BEGIN_SRC nsis
  CRCCheck On
  RequestExecutionLevel user
  ; Best Compression
  SetCompress Auto
  SetCompressor /SOLID lzma
  SetCompressorDictSize 32
  SetDatablockOptimize On
  Caption "Loading EmacsPortable.App"
  Subcaption 3 " "
  XPStyle on
  !ifdef __EP_DEBUG__
    OutFile "..\..\..\App\eps\epl.exe"
    Icon "..\img\ico\bug.ico"
    !else 
    OutFile "..\..\..\App\eps\ep.exe"
    Icon "..\img\ico\appicon.ico"
  !endif
  UninstallIcon "..\img\ico\trash_empty.ico"
#+END_SRC

** User Interface
EmacsPortable.App uses the loading bar to startup emacs.
#+BEGIN_SRC nsis 
  !ifndef __EP_DEBUG__
    AutoCloseWindow true
    ChangeUI all "${NSISDIR}\Contrib\UIs\LoadingBar_Icon.exe"
  !endif
#+END_SRC

** Variables
#+BEGIN_SRC nsis
  Var home
  Var mount
  Var cygwin
  Var msys
  Var found_gdb
  Var emacs
  Var emacs_dir
  Var emacs_exe
  Var emacs_client_exe
  Var cmd_args
  Var cmd
  Var cnt
  Var real_temp
  
  Var Rpath
  
  Var server_file
  var cmdLineParams
  
  Var option_batch
  Var option_debug
  Var option_silent
  Var option_debug_from_ini
  var option_dos
  var option_q
  var option_version
  var option_home
  var option_home_usb
  var option_toolbar
  var option_menubar
  var option_minibuffer
  var option_scrollbar
  var option_background
  var option_foreground
  var option_daemon
  var option_colorsync
  var option_updateproxy
  var option_help
  var option_cmd
  
  var option_font
  var option_font_size
  
  var option_geometry
  var option_maximized
  var option_fullwidth
  var option_fullheight
  var PA
  
  Var nini
  Var EPEXE
  Var epdata
  Var epstart
#+END_SRC

** Headers and Plug ins
#+BEGIN_SRC nsis
  !include "FileFunc.nsh"
  !include "StrRep.nsh"
  !include "ReadINIStrWithDefault.nsh"
  !include "blowfish.nsh"
  !include "logiclib.nsh"
  !include "WinMessages.nsh"
  !include "setupEmacsData.nsh"
  !include "RepInFile.nsh"
  !include "emacsEnv.nsh"
  !include "procfunc.nsh"
#+END_SRC

* Macros/Functions
** Trim
#+BEGIN_SRC nsis
; Trim
;   Removes leading & trailing whitespace from a string
; Usage:
;   Push
;   Call Trim
;   Pop

!macro _Trim ORIGINAL_STRING
  Push "${ORIGINAL_STRING}"
  Call _Trim_
  Pop $0
!macroend

!define Trim '!insertmacro "_Trim"'

Function _Trim_
  Exch $R1 ; Original string
  Push $R2
  
  Loop:
    StrCpy $R2 "$R1" 1
    StrCmp "$R2" " " TrimLeft
    StrCmp "$R2" "$\r" TrimLeft
    StrCmp "$R2" "$\n" TrimLeft
    StrCmp "$R2" "$\t" TrimLeft
    GoTo Loop2
  TrimLeft:
    StrCpy $R1 "$R1" "" 1
    Goto Loop
    
  Loop2:
    StrCpy $R2 "$R1" 1 -1
    StrCmp "$R2" " " TrimRight
    StrCmp "$R2" "$\r" TrimRight
    StrCmp "$R2" "$\n" TrimRight
    StrCmp "$R2" "$\t" TrimRight
    
    GoTo Done
  TrimRight:
    StrCpy $R1 "$R1" -1
    Goto Loop2
    
  Done:
    Pop $R2
    Exch $R1
FunctionEnd
#+END_SRC
** Split at Equals
#+BEGIN_SRC nsis
## Split Equals
!macro SPLIT_EQUALS INPUT PART
  Push $R0
  Push $R1
  
  StrCpy $R0 0
  StrCmp ${PART} 1 getpart1_loop_${PART}
  StrCmp ${PART} 2 getpart2_top_${PART}
  Goto error_${PART}
  
  getpart1_loop_${PART}:
    IntOp $R0 $R0 - 1
    StrCpy $R1 ${INPUT} 1 $R0
    StrCmp $R1 "" error_${PART}
    StrCmp $R1 "=" 0 getpart1_loop_${PART}
    
    IntOp $R0 $R0 + 1
    StrCpy $R0 ${INPUT} "" $R0
    Goto done_${PART}
    
  getpart2_top_${PART}:
    StrLen $R0 ${INPUT}
  getpart2_loop_${PART}:
    IntOp $R0 $R0 - 1
    StrCpy $R1 ${INPUT} 1 -$R0
    StrCmp $R1 "" error_${PART}
    StrCmp $R1 "=" 0 getpart2_loop_${PART}
    
    StrCpy $R0 ${INPUT} -$R0
    Goto done_${PART}
    
  error_${PART}:
    StrCpy $R0 error
    
  done_${PART}:
    
    Pop $R1
    Exch $R0
!macroend
#+END_SRC

** Setup Emacs EXE
#+BEGIN_SRC nsis
  Function SetupEmacsExe
    ${If} $epstart == "-"
      StrCpy $epstart ""
    ${EndIf}
    ${If} $option_q != ""
      StrCpy $epstart "-q"
    ${EndIf}
    StrCmp "" $option_dos setupwin setupdos
    setupdos:
      IfFileExists "$emacs_dir\emacs-$option_version$epstart-dos.exe" end
      
      IfFileExists "$emacs_dir\emacs-$option_version.exe" 0 +3
      CopyFiles /SILENT "$emacs_dir\emacs-$option_version.exe" "$emacs_dir\emacs-$option_version$epstart-dos.exe"
      Goto end
      
      IfFileExists "$emacs_dir\emacs.exe" 0 not_found
      CopyFiles /SILENT "$emacs_dir\emacs.exe" "$emacs_dir\emacs-$option_version$epstart-dos.exe"
      Goto end
      
    setupwin:
      IfFileExists "$emacs_dir\emacs-$option_version$epstart.exe" end
  
      IfFileExists "$emacs_dir\emacs-$option_version.exe" 0 +3
      CopyFiles /SILENT "$emacs_dir\emacs-$option_version.exe" "$emacs_dir\emacs-$option_version$epstart.exe"
      Goto end
      
      IfFileExists "$emacs_dir\emacs.exe" 0 not_found
      CopyFiles /SILENT "$emacs_dir\emacs.exe" "$emacs_dir\emacs-$option_version$epstart.exe"
      
      Goto end
    not_found:
      
      MessageBox MB_OK|MB_ICONEXCLAMATION "Could not find Emacs...$\nInstallation may be corrupt.$\nSelect or download appropriate version$\nEmacs Version: $option_version$\nEmacs Dir: $emacs_dir"
      ExecWait "$EXEDIR\..\..\EmacsOptions.exe"
      ExecWait "$EXEDIR\..\..\EmacsPortableApp.exe"
      Abort
    end:
      #
  FunctionEnd
  !define SetupEmacsExe "Call SetupEmacsExe"
  
#+END_SRC
** Get Windows Version
From http://nsis.sourceforge.net/Get_Windows_version
#+BEGIN_SRC nsis
  ; GetWindowsVersion 2.0 (2008-01-07)
  ;
  ; Based on Yazno's function, http://yazno.tripod.com/powerpimpit/
  ; Update by Joost Verburg
  ; Update (Macro, Define, Windows 7 detection) - John T. Haller of PortableApps.com - 2008-01-07
  ;
  ; Usage: ${GetWindowsVersion} $R0
  ;
  ; $R0 contains: 95, 98, ME, NT x.x, 2000, XP, 2003, Vista, 7 or '' (for unknown)
   
  Function GetWindowsVersion
   
    Push $R0
    Push $R1
   
    ClearErrors
   
    ReadRegStr $R0 HKLM \
    "SOFTWARE\Microsoft\Windows NT\CurrentVersion" CurrentVersion
   
    IfErrors 0 lbl_winnt
   
    ; we are not NT
    ReadRegStr $R0 HKLM \
    "SOFTWARE\Microsoft\Windows\CurrentVersion" VersionNumber
   
    StrCpy $R1 $R0 1
    StrCmp $R1 '4' 0 lbl_error
   
    StrCpy $R1 $R0 3
   
    StrCmp $R1 '4.0' lbl_win32_95
    StrCmp $R1 '4.9' lbl_win32_ME lbl_win32_98
   
    lbl_win32_95:
      StrCpy $R0 '95'
    Goto lbl_done
   
    lbl_win32_98:
      StrCpy $R0 '98'
    Goto lbl_done
   
    lbl_win32_ME:
      StrCpy $R0 'ME'
    Goto lbl_done
   
    lbl_winnt:
   
    StrCpy $R1 $R0 1
   
    StrCmp $R1 '3' lbl_winnt_x
    StrCmp $R1 '4' lbl_winnt_x
   
    StrCpy $R1 $R0 3
   
    StrCmp $R1 '5.0' lbl_winnt_2000
    StrCmp $R1 '5.1' lbl_winnt_XP
    StrCmp $R1 '5.2' lbl_winnt_2003
    StrCmp $R1 '6.0' lbl_winnt_vista
    StrCmp $R1 '6.1' lbl_winnt_7 lbl_error
   
    lbl_winnt_x:
      StrCpy $R0 "NT $R0" 6
    Goto lbl_done
   
    lbl_winnt_2000:
      Strcpy $R0 '2000'
    Goto lbl_done
   
    lbl_winnt_XP:
      Strcpy $R0 'XP'
    Goto lbl_done
   
    lbl_winnt_2003:
      Strcpy $R0 '2003'
    Goto lbl_done
   
    lbl_winnt_vista:
      Strcpy $R0 'Vista'
    Goto lbl_done
   
    lbl_winnt_7:
      Strcpy $R0 '7'
    Goto lbl_done
   
    lbl_error:
      Strcpy $R0 ''
    lbl_done:
   
    Pop $R1
    Exch $R0
   
  FunctionEnd
   
  !macro GetWindowsVersion OUTPUT_VALUE
          Call GetWindowsVersion
          Pop `${OUTPUT_VALUE}`
  !macroend
   
  !define GetWindowsVersion '!insertmacro "GetWindowsVersion"'
#+END_SRC
** Execute Hidden (and get PID)
This is based on the procfunc.nsh file modified to start hidden dos boxes.
#+BEGIN_SRC nsis
  !macro ExecHide
  !macroend
  !define ExecHide "!insertmacro ExecHideCall "
  !macro ExecHideCall cmdline wrkdir outVar
    !verbose push
    !verbose ${_PROCFUNC_VERBOSE}
    Push `${wrkdir}`
    Push `${cmdline}`
    ${CallArtificialFunction} ExecHide_
    Pop ${outVar}
    !verbose pop
  !macroend
  !define STARTF_USESHOWWINDOW 0x00000001
  !define STARTF_USECOUNTCHARS 0x00000008
  !define /math STARTF_HIDE ${STARTF_USESHOWWINDOW} | ${STARTF_USECOUNTCHARS}
  
  !macro ExecHide_
    System::Store "s" ; store registers in System's private stack
    Pop $0 ; cmdline
    Pop $1 ; wrkdir
  
    System::Alloc 68 ; 4*16 + 2*2 / STARTUPINFO structure = $2
    Pop $2
    ##
    
    System::Call '*(i 68, w,w,w, i 0,i 0, i 80,i 60, i 80,i 25, i,i ${STARTF_HIDE}, i 0x00)i .r2' ; set cb = sizeof(STARTUPINFO)
    System::Call '*(i,i,i,i)i .r3' ; PROCESS_INFORMATION structure = $3
    
    ${If} $1 == ""
      StrCpy $1 "i"
    ${Else}
      StrCpy $1 'w "$1"'
    ${EndIf}
    
    System::Call `kernel32::CreateProcessW(i, w '$0', i, i, i 0, i 0, i, $1, i r2, i r3)i .r4` ; return 0 if fail
    ${Unless} $4 = 0 ; failed to create process
      System::Call '*$3(i .r4, i .r5, i .r6)' ; read handles and PID
      System::Call 'kernel32::CloseHandle(i $4)' ; close hProcess
      System::Call 'kernel32::CloseHandle(i $5)' ; close hThread
      Push $6 ; return PID
    ${Else}
      Push 0 ; return val if failed
    ${EndUnless}
    
    System::Free $2 ; free STARTUPINFO struct
    System::Free $3 ; free PROCESS_INFORMATION struct
    System::Store "l" ; restore registers
  !macroend
  
#+END_SRC

** Get Disk Volume Serial Number
http://nsis.sourceforge.net/Get_Disk_Volume_Serial_Number
#+BEGIN_SRC nsis
!define _GetVolumeInformationSysCall "Kernel32::GetVolumeInformation(t,t,i,*i,*i,*i,t,i) i"
!macro GetDiskVolumeSerialNumber _SERIAL _DRIVE
  Push $0
  System::Call '${_GetVolumeInformationSysCall}("${_DRIVE}",,${NSIS_MAX_STRLEN},.r0,,,,${NSIS_MAX_STRLEN})'
  Exch $0
  Pop ${_SERIAL}
!macroend
!define GetDiskVolumeSerialNumber "!insertmacro GetDiskVolumeSerialNumber"
 
!macro GetDiskVolumeSerialNumberHex _SERIAL _DRIVE
  ${GetDiskVolumeSerialNumber} ${_SERIAL} ${_DRIVE}
  IntFmt ${_SERIAL} "%08X" ${_SERIAL}
!macroend
!define GetDiskVolumeSerialNumberHex "!insertmacro GetDiskVolumeSerialNumberHex"
#+END_SRC

** Explode
From http://nsis.sourceforge.net/Explode
#+BEGIN_SRC nsis
  !define Explode "!insertmacro Explode"
   
  !macro  Explode Length  Separator   String
      Push    `${Separator}`
      Push    `${String}`
      Call    Explode
      Pop     `${Length}`
  !macroend
     
  Function Explode
    ; Initialize variables
    Var /GLOBAL explString
    Var /GLOBAL explSeparator
    Var /GLOBAL explStrLen
    Var /GLOBAL explSepLen
    Var /GLOBAL explOffset
    Var /GLOBAL explTmp
    Var /GLOBAL explTmp2
    Var /GLOBAL explTmp3
    Var /GLOBAL explArrCount
   
    ; Get input from user
    Pop $explString
    Pop $explSeparator
   
    ; Calculates initial values
    StrLen $explStrLen $explString
    StrLen $explSepLen $explSeparator
    StrCpy $explArrCount 1
   
    ${If}   $explStrLen <= 1          ;   If we got a single character
    ${OrIf} $explSepLen > $explStrLen ;   or separator is larger than the string,
      Push    $explString             ;   then we return initial string with no change
      Push    1                       ;   and set array's length to 1
      Return
    ${EndIf}
   
    ; Set offset to the last symbol of the string
    StrCpy $explOffset $explStrLen
    IntOp  $explOffset $explOffset - 1
   
    ; Clear temp string to exclude the possibility of appearance of occasional data
    StrCpy $explTmp   ""
    StrCpy $explTmp2  ""
    StrCpy $explTmp3  ""
   
    ; Loop until the offset becomes negative
    ${Do}
      ;   If offset becomes negative, it is time to leave the function
      ${IfThen} $explOffset == -1 ${|} ${ExitDo} ${|}
      
      ;   Remove everything before and after the searched part ("TempStr")
      StrCpy $explTmp $explString $explSepLen $explOffset
      
      ${If} $explTmp == $explSeparator
          ;   Calculating offset to start copy from
          IntOp   $explTmp2 $explOffset + $explSepLen ;   Offset equals to the current offset plus length of separator
          StrCpy  $explTmp3 $explString "" $explTmp2
          
          Push    $explTmp3                           ;   Throwing array item to the stack
          IntOp   $explArrCount $explArrCount + 1     ;   Increasing array's counter
          
          StrCpy  $explString $explString $explOffset 0   ;   Cutting all characters beginning with the separator entry
          StrLen  $explStrLen $explString
      ${EndIf}
   
      ${If} $explOffset = 0                       ;   If the beginning of the line met and there is no separator,
                                                  ;   copying the rest of the string
          ${If} $explSeparator == ""              ;   Fix for the empty separator
              IntOp   $explArrCount   $explArrCount - 1
          ${Else}
              Push    $explString
          ${EndIf}
      ${EndIf}
   
      IntOp   $explOffset $explOffset - 1
    ${Loop}
   
    Push $explArrCount
  FunctionEnd
#+END_SRC
* Command Line Options
** Get Command Line Options
#+BEGIN_SRC nsis
    
    !define GetCmdOptions "!insertmacro GetCmdOptions"
    
    !macro GetCmdOptions
      Call GetCmdOptions
    !macroend
  Function GetCmdOptions
      ## Gets Command LiFunctions
      Push $R0
      
      ; /? param (help)
      ClearErrors
      ${GetOptions} $cmdLineParams '/?' $R0
      IfErrors +3 0
      MessageBox MB_OK "Usage: EmacsPortableApp.exe [OPTION-FILENAME]...$\n$\n\
          /?$\t$\tShow this help$\n\
          /CMD$\t$\tRuns Command Prompt with Emacs Environment\
          /UPDATEPROXY$\tUpdates the Proxy settings of running emacs sessions.$\n\
          /COLORSYNC$\tSync the fonts and display colors with the startup options$\n\
          /DEBUG$\t$\tStart Emacs in debugger mode on initial startup.$\n\
          /DOS$\t$\tStart Emacs in DOS mode on initial startup.$\n\
          /Q$\t$\tStart Emacs with NO site file and NO splash screen.$\n\
          /SILENT$\t$\tRun --batch files without showing command prompt.$\n\
          /VERSION=ver$\tRun using Emacs versionver if exists.$\n\
          $\n\
          Also accepts standard emacs arguments or emacsclient arguments depending on$\n\
          if the launcher has detected a running emacs."
      Abort
      
      
      Pop $R0
      
      ; Initialize options
      
      
      StrCpy $option_fullwidth 0
      StrCpy $option_fullheight 1
      StrCpy $option_maximized 0
      StrCpy $option_geometry "80x70+0+0"
      StrCpy $option_background "black"
      StrCpy $option_foreground "white"
      StrCpy $option_daemon "1"             
      StrCpy $option_debug ""
      StrCpy $option_debug_from_ini ""
      StrCpy $option_dos ""
      StrCpy $option_q ""
      StrCpy $option_version "24.1"
      FindFirst $0 $1 $EXEDIR\..\emacs-*.*
      ${While} $1 != ""
        ${If} ${FileExists} $EXEDIR\..\$1\etc
          StrCpy $option_version $1 "" 6
        ${EndIf}
        ${If} ${FileExists} $EXEDIR\..\$1\share
          StrCpy $option_version $1 "" 6
        ${EndIf}
        FindNext $0 $1 
      ${EndWhile}
      
      FindFirst $0 $1 $EXEDIR\..\emacs\bin\emacs-*.exe
      ${While} $1 != ""
        StrCpy $option_version $1 "" 6
        StrCpy $option_version $option_version -4
        FindNext $0 $1
      ${EndWhile}
      
      StrCpy $option_font "Inconsolata"
      StrCpy $option_font_size 18
      StrCpy $option_colorsync ""    
      StrCpy $option_cmd ""
      StrCpy $option_updateproxy ""
      StrCpy $option_silent ""
      
      StrCpy $emacs_client_exe "emacsclient.exe"
      ; Parse Parameters
      Push $R0
      Call parseParameters
      Pop $R0
    FunctionEnd
    
#+END_SRC
** Parse Parameters
#+BEGIN_SRC nsis  
  Function parseParameters
    ${ReadINIStrWithDefault} $option_version $epdata\ini\EmacsPortableApp.ini "EmacsPortableApp" "Version" $option_version
    ${ReadINIStrWithDefault} $epstart $epdata\ini\EmacsPortableApp.ini "EmacsPortableApp" "Startup" $epstart
    
    # If a version of emacs is running, use that.
    
    FindProcDLL::FindProc "emacs-$option_version-$epstart.exe"
    StrCmp $R0 "1" already_running
    FindFirst $0 $1 "$EXEDIR\..\emacs-*"
    StrCpy $2 ""
    StrCpy $3 ""
    StrCpy $9 ""
    loop_find_running:
      StrCmp "$1" "" next_type_of_run  0
      StrCpy $1 $1 "" 6
      ${If} $2 != ""
      ${AndIfNot} ${FileExists} "$EXEDIR\..\..\EmacsPortableApp-$2.exe"
      ${AndIf} ${FileExists} $EXEDIR\..\emacs-$2\etc
        CopyFiles /SILENT "$EXEDIR\ver-shortcut.exe" "$EXEDIR\..\..\EmacsPortableApp-$2.exe"
        StrCpy $3 "1"
      ${EndIf}
  
      ${If} $2 != ""
      ${AndIfNot} ${FileExists} "$EXEDIR\..\..\EmacsPortableApp-$2.exe"
      ${AndIf} ${FileExists} $EXEDIR\..\emacs-$2\share\emacs\$2\etc
        CopyFiles /SILENT "$EXEDIR\ver-shortcut.exe" "$EXEDIR\..\..\EmacsPortableApp-$2.exe"
        StrCpy $3 "1"
      ${EndIf}
      
      ${If} $3 != ""
      ${AndIfNot} ${FileExists} "$EXEDIR\..\..\EmacsPortableApp-$1.exe"
      ${AndIf} ${FileExists} $EXEDIR\..\emacs-$1\etc
        CopyFiles /SILENT "$EXEDIR\ver-shortcut.exe" "$EXEDIR\..\..\EmacsPortableApp-$1.exe"
      ${EndIf}
  
      ${If} $3 != ""
      ${AndIfNot} ${FileExists} "$EXEDIR\..\..\EmacsPortableApp-$1.exe"
      ${AndIf} ${FileExists} $EXEDIR\..\emacs-$1\share\emacs\$1\etc
        CopyFiles /SILENT "$EXEDIR\ver-shortcut.exe" "$EXEDIR\..\..\EmacsPortableApp-$1.exe"
      ${EndIf}
      
      FindProcDLL::FindProc "emacs-$1.exe"
      ${If} $R0 == "1"
        StrCpy $option_version $1
        StrCpy $epstart ""
      ${Else}
        FindFirst $3 $4 $EXEDIR\..\..\Data\start\*.*
        ${While} $4 != ""
          ${If} $4 != "."
          ${AndIf} $4 != ".."
          ${AndIf} $4 != "shared"
          ${AndIf} $4 != "system"
          ${AndIf} $4 != "user"
            FindProcDLL::FindProc "emacs-$1-$4.exe"
            ${If} $R0 == "1"
              StrCpy $9 "1"
              StrCpy $option_version $1
              StrCpy $epstart $4
            ${EndIf}
          ${EndIf}
          FindNext $3 $4
        ${EndWhile}
      ${EndIf}
      StrCpy $2 $1
      FindNext $0 $1
      Goto loop_find_running
    next_type_of_run:
      ;; Now look for emacs/bin/emacs-*...
      FindFirst $0 $1 "$EXEDIR\..\emacs\bin\emacs-*.exe"
      
    loop_next_type_of_run:
      StrCmp "$1" "" third_type_of_run  0
      StrCpy $1 $1 "" 6
      StrCpy $1 $1 "" -4
      ${If} $2 != ""
      ${AndIfNot} ${FileExists} "$EXEDIR\..\..\EmacsPortableApp-$2.exe"
      ${AndIf} ${FileExists} $EXEDIR\..\emacs\bin\emacs-$2.exe
        CopyFiles /SILENT "$EXEDIR\ver-shortcut.exe" "$EXEDIR\..\..\EmacsPortableApp-$2.exe"
        StrCpy $3 "1"
      ${EndIf}
      ${If} $3 != ""
      ${AndIfNot} ${FileExists} "$EXEDIR\..\..\EmacsPortableApp-$1.exe"
      ${AndIf} ${FileExists} $EXEDIR\..\emacs\bin\emacs-$1.exe
        CopyFiles /SILENT "$EXEDIR\ver-shortcut.exe" "$EXEDIR\..\..\EmacsPortableApp-$1.exe"
      ${EndIf}
      FindProcDLL::FindProc "emacs-$1.exe"
      ${If} $R0 == "1"
        StrCpy $option_version $1
        StrCpy $epstart ""
      ${Else}
        FindFirst $3 $4 $EXEDIR\..\..\Data\start\*.*
        ${While} $4 != ""
          ${If} $4 != "."
          ${AndIf} $4 != ".."
          ${AndIf} $4 != "shared"
          ${AndIf} $4 != "system"
          ${AndIf} $4 != "user"
            FindProcDLL::FindProc "emacs-$1-$4.exe"
            ${If} $R0 == "1"
              StrCpy $9 "1"
              StrCpy $option_version $1
              StrCpy $epstart $4
            ${EndIf}
          ${EndIf}
          FindNext $3 $4
        ${EndWhile}
      ${EndIf}
      StrCpy $2 $1
      FindNext $0 $1
      Goto loop_next_type_of_run
    third_type_of_run:
      ;; Now look for emacs/bin/bare-bin-*...
      FindFirst $0 $1 "$EXEDIR\..\emacs\bin\bare-bin-*.7z"
    loop_third:
      StrCmp "$1" "" not_running  0
      StrCpy $1 $1 "" 9
      StrCpy $1 $1 "" -3
      ${If} $2 != ""
      ${AndIfNot} ${FileExists} "$EXEDIR\..\..\EmacsPortableApp-$2.exe"
      ${AndIf} ${FileExists} $EXEDIR\..\emacs\bare-bin-$2.7z
        CopyFiles /SILENT "$EXEDIR\ver-shortcut.exe" "$EXEDIR\..\..\EmacsPortableApp-$2.exe"
        StrCpy $3 "1"
      ${EndIf}
      ${If} $3 != ""
      ${AndIfNot} ${FileExists} "$EXEDIR\..\..\EmacsPortableApp-$1.exe"
      ${AndIf} ${FileExists} $EXEDIR\..\emacs\bin\bare-bin-$1.7z
        CopyFiles /SILENT "$EXEDIR\ver-shortcut.exe" "$EXEDIR\..\..\EmacsPortableApp-$1.exe"
      ${EndIf}
      FindProcDLL::FindProc "emacs-$1.exe"
      ${If} $R0 == "1"
        StrCpy $option_version $1
        StrCpy $epstart ""
      ${Else}
        FindFirst $3 $4 $EXEDIR\..\..\Data\start\*.*
        ${While} $4 != ""
          ${If} $4 != "."
          ${AndIf} $4 != ".."
          ${AndIf} $4 != "shared"
          ${AndIf} $4 != "system"
          ${AndIf} $4 != "user"
            FindProcDLL::FindProc "emacs-$1-$4.exe"
            ${If} $R0 == "1"
              StrCpy $9 "1"
              StrCpy $option_version $1
              StrCpy $epstart $4
            ${EndIf}
          ${EndIf}
          FindNext $3 $4
        ${EndWhile}
      ${EndIf}
      StrCpy $2 $1
      FindNext $0 $1
      Goto loop_next_type_of_run
      
      ;; Not running
    not_running:
      ${If} "$9" == "1"
      ${AndIf} ${FileExists} "$real_temp\ep\ep-rm.exe"
        ExecWait "$real_temp\ep\ep-rm.exe /SKIP"
      ${EndIf}
    already_running:
      
      ${ReadINIStrWithDefault} $option_geometry $epdata\ini\EmacsPortableApp.ini \
          "EmacsPortableApp" "Geometry" $option_geometry
      
      ${ReadINIStrWithDefault} $option_maximized $epdata\ini\EmacsPortableApp.ini \
          "EmacsPortableApp" "Max" $option_maximized 
      
      ${ReadINIStrWithDefault} $option_fullwidth $epdata\ini\EmacsPortableApp.ini \
          "EmacsPortableApp" "Fullwidth" $option_fullwidth
      
      ${ReadINIStrWithDefault} $option_fullheight $epdata\ini\EmacsPortableApp.ini \
          "EmacsPortableApp" "Fullheight" $option_fullheight
      
      ${ReadINIStrWithDefault} $option_font $epdata\ini\EmacsPortableApp.ini \
          "EmacsPortableApp" "Font" $option_font
      
      ${ReadINIStrWithDefault} $option_font_size $epdata\ini\EmacsPortableApp.ini \
          "EmacsPortableApp" "FontSize" $option_font_size
      ${ReadINIStrWithDefault} $option_toolbar $epdata\ini\EmacsPortableApp.ini \
          "EmacsPortableApp" "Toolbar" $option_toolbar
      
      ${ReadINIStrWithDefault} $option_menubar $epdata\ini\EmacsPortableApp.ini \
          "EmacsPortableApp" "Menubar" $option_menubar
      ${ReadINIStrWithDefault} $option_scrollbar $epdata\ini\EmacsPortableApp.ini \
          "EmacsPortableApp" "ScrollBars" $option_scrollbar
      ${ReadINIStrWithDefault} $option_minibuffer $epdata\ini\EmacsPortableApp.ini \
          "EmacsPortableApp" "Minibuffer" $option_minibuffer
      ${ReadINIStrWithDefault} $option_background $epdata\ini\EmacsPortableApp.ini \
          "EmacsPortableApp" "Background" $option_background
      ${ReadINIStrWithDefault} $option_foreground $epdata\ini\EmacsPortableApp.ini \
          "EmacsPortableApp" "Foreground" $option_foreground
      ${ReadINIStrWithDefault} $option_daemon $epdata\ini\EmacsPortableApp.ini \
          "EmacsPortableApp" "Daemon" $option_daemon
      
      StrCmp "1" $option_daemon 0 +2
      System::Call 'Kernel32::SetEnvironmentVariableA(t, t) i("EMACS_DAEMON", "1").r0'
      
      ## Now Replace standard emacs options with EmacsPortableApp.org options.
      ${StrRep} $cmdLineParams $cmdLineParams "-Q" "/Q"
      
      ## GetOptions readst the WHOLE string so things like
      ## EmacsPortableApp /VERSION=24.1 --eval "(message (symbol-name 'ok))" wil not work.
      
      ${GetOptions} $cmdLineParams '/START=' $R0
      ${If} ${Errors}
        ClearErrors
      ${Else}
        ${Explode} $R1  " " $R0
        Pop $R0
        ${For} $R3 1 $R1
          Pop $R4
        ${Next}
        StrCpy $epstart $R0
        ${StrRep} $cmdLineParams $cmdLineParams "/START=$epstart" ""
      ${EndIf}
  
      ;; Setup environmental variables for startup
      ${If} $epstart == "None"
        StrCpy $epstart ""
        System::Call 'Kernel32::SetEnvironmentVariableA(t, t) i("EPSTART", ).r0'
        System::Call 'Kernel32::SetEnvironmentVariableA(t, t) i("EPSTARTDIR", ).r0'
      ${Else}
        ${If} ${FileExists} "$EXEDIR\..\..\Data\start\$epstart\*.*"
          System::Call 'Kernel32::SetEnvironmentVariableA(t, t) i("EPSTART", "$epstart").r0'
          System::Call 'Kernel32::SetEnvironmentVariableA(t, t) i("EPSTARTDIR", "$EXEDIR\..\..\Data\start\$epstart").r0'
          StrCpy $epstart "-$epstart"
        ${ElseIf} ${FileExists} "$epdata\start\$epstart\*.*"
          System::Call 'Kernel32::SetEnvironmentVariableA(t, t) i("EPSTART", "$epstart").r0'
          System::Call 'Kernel32::SetEnvironmentVariableA(t, t) i("EPSTARTDIR", "$epdata\start\$epstart").r0'
          StrCpy $epstart "-$epstart"
        ${Else}
          System::Call 'Kernel32::SetEnvironmentVariableA(t, t) i("EPSTART", ).r0'
          System::Call 'Kernel32::SetEnvironmentVariableA(t, t) i("EPSTARTDIR", ).r0'
          StrCpy $epstart ""
        ${EndIf}
      ${EndIf}
  
      ${If} $epstart == "-"
        StrCpy $epstart ""
      ${EndIf}
      
      ${GetOptions} $cmdLineParams '/VERSION=' $R0
      IfErrors read_cmd_line_ver
      ${Explode} $R1  " " $R0
      Pop $R0
      ${For} $R3 2 $R1
        Pop $R4
      ${Next}
      StrCpy $option_version $R0
      ${StrRep} $cmdLineParams $cmdLineParams "/VERSION=$option_version" ""
      ## Check to see if any of the known 
  
    read_cmd_line_ver:
      ClearErrors
      StrCpy $emacs_exe "emacs-$option_version$epstart.exe"
      IfFileExists "$EXEDIR\..\emacs-$option_version\lisp" emacs_ver_done
      IfFileExists "$EXEDIR\..\emacs-$option_version\share\emacs\$option_version\lisp" emacs_ver_done
      
      IfFileExists "$EXEDIR\..\..\EmacsPortableApp-$option_version.exe" 0 +2
      Delete "$EXEDIR\..\..\EmacsPortableApp-$option_version.exe"
      
      FindFirst $0 $1 $EXEDIR\..\emacs-*.*
    loop_ver:
      StrCmp $1 "" done_ver
      ${If} ${FileExists} $EXEDIR\..\$1\etc
        StrCpy $1 $1 "" 6
        StrCpy $2 $1
      ${EndIf}
      
      ${If} ${FileExists} $EXEDIR\..\$1\share
        StrCpy $1 $1 "" 6
        StrCpy $2 $1
      ${EndIf}
      FindNext $0 $1
      Goto loop_ver
    done_ver:
      FindClose $0
      MessageBox MB_YESNO|MB_ICONEXCLAMATION "Emacs $option_version not found!$\n$\n Run emacs $2 instead?" IDYES set_new_ver IDNO abort_run
    set_new_ver:
      ## Save known version string if it is not saved correctly.
      ReadIniStr $1 "$epdata\ini\EmacsPortableApp.ini" "EmacsPortableApp" "Version"
      ClearErrors
      StrCmp $1 "" +2
      StrCmp $1 $option_version 0 +2
      WriteIniStr "$epdata\ini\EmacsPortableApp.ini" "EmacsPortableApp" "Version" $2
      
      StrCpy $option_version $2
      StrCpy $emacs_exe "emacs-$option_version$epstart.exe"
      
      Goto emacs_ver_done
    abort_run:
      Abort
    emacs_ver_done:
      ClearErrors
      ${GetOptions} $cmdLineParams '/COLORSYNC' $R0
      IfErrors no_colorsync
      StrCpy $option_colorsync "1"
    no_colorsync:
      ClearErrors
      ${GetOptions} $cmdLineParams '/UPDATEPROXY' $R0
      IfErrors no_proxy
      StrCpy $option_updateproxy "1"
    no_proxy:
      ClearErrors
      ${GetOptions} $cmdLineParams '/SILENT' $R0
      IfErrors no_silent
      StrCpy $option_silent "1"
      
    no_silent:
      ClearErrors
      ${GetOptions} $cmdLineParams '--batch' $R0
      IfErrors no_batch
      StrCpy $option_batch "1"
      StrCpy $option_q " -Q"
      
    no_batch:
      ClearErrors
      ${GetOptions} $cmdLineParams '--help' $R0
      IfErrors no_help
      StrCpy $option_help "1"
    no_help:
      ClearErrors
      ${GetOptions} $cmdLineParams '/DEBUG' $R0
      IfErrors no_debug_cmd_line
      StrCpy $option_debug " --debug-init"
      Goto emacs_debug_done
    no_debug_cmd_line:
      ClearErrors
      IfFileExists $epdata\ini\EmacsPortableApp.ini read_debug_ini_file
      StrCpy $option_debug ""
      Goto emacs_debug_done
    read_debug_ini_file:
      ClearErrors
      ${ReadINIStrWithDefault} $option_debug $epdata\ini\EmacsPortableApp.ini "EmacsPortableApp" "Debug" "0"
      StrCmp $option_debug "1" 0 no_debugging
      StrCpy $option_debug " --debug-init"
      StrCpy $option_debug_from_ini "1"
      Goto emacs_debug_done
    no_debugging:
      ClearErrors
      StrCpy $option_debug ""
    emacs_debug_done:
      ClearErrors
      
      ${GetOptions} $cmdLineParams '/Q' $R0
      IfErrors no_q
      StrCpy $option_q " -Q"
    no_q:
      ClearErrors
      ${GetOptions} $cmdLineParams '/CMD' $R0
      IfErrors no_cmd
      StrCpy $option_cmd "1"
      StrCpy $option_q " -Q"
    no_cmd:
      ClearErrors
      ${GetOptions} $cmdLineParams '/DOS' $R0
      IfErrors no_dos
      StrCpy $option_dos " -nw"
      StrCpy $emacs_exe "emacs-$option_version$epstart-dos.exe"
      StrCpy $emacs_client_exe "emacsclient.exe"
    no_dos:
      ClearErrors
      ;; Now take out all known parameters
      
      ${StrRep} $cmdLineParams $cmdLineParams "/Q" ""
      ${StrRep} $cmdLineParams $cmdLineParams "/CMD" ""
      ${StrRep} $cmdLineParams $cmdLineParams "/DOS" ""
      ${StrRep} $cmdLineParams $cmdLineParams "/DEBUG" ""
      
      ${StrRep} $cmdLineParams $cmdLineParams "/COLORSYNC" ""
      ${StrRep} $cmdLineParams $cmdLineParams "/UPDATEPROXY" ""
      ${StrRep} $cmdLineParams $cmdLineParams "/SILENT" ""
      
      ${Trim} $cmdLineParams
      StrCpy $cmdLineParams $0
      
      
      StrCmp "" $option_dos setupwin setupdos
    setupdos:
      StrCpy $server_file "$real_temp\ep\epd-$option_version$epstart\server"
      Goto end
    setupwin:
      StrCpy $server_file "$real_temp\ep\EmacsPortable.App-Server-$option_version$epstart\server"
    end:
      ## Change protocol spaces to %20
      StrCpy $0 $cmdLineParams 15
      StrCmp $0 "$\"org-protocol:/" 0 final
      ${StrRep} $cmdLineParams $cmdLineParams " " "%20"
    final:
      DetailPrint "Removed stale server files"
      ClearErrors
  FunctionEnd
  
#+END_SRC

* Setup Environment
** Get Portable Apps Directories
#+BEGIN_SRC nsis
  Function GetDriveVars
    StrCmp $9 "c:\" findcygwin
    StrCmp $8 "HDD" gpa
    StrCmp $9 "a:\" spa
    StrCmp $9 "b:\" spa
    
    gpa:
      StrCmp $option_home_usb "" set_usb 0
      IfFileExists "$9$option_home_usb" 0 is_emacs_portable
      IfFileExists "$9$option_home_usb\.emacs" set_home 0
      IfFileExists "$9$option_home_usb\_emacs" set_home 0
      ${If} ${FileExists} "$EPEXE\App\ini\paths.ini"
        Push $R0
        Push $R1
        EnumINI::Section "$EPEXE\App\ini\paths.ini" "portable.dirs"
        Pop $R0
        ${If} $R0 != "error"
          ${DoUntil} $R0 == "0"
            Pop $R1
            ${If} ${FileExists} "$9$R1"
              StrCpy $home "$9$option_home_usb"
              StrCpy $PA "$9PortableApps" 
            ${EndIf}
            IntOp $R0 $R0 - 1
          ${Loop}
        ${EndIf}
        Pop $R1
        Pop $R0
      ${EndIf}
      
      IfFileExists "$9EmacsPortable.App\EmacsPortableApp.exe" set_home
      Goto findcygwin
      
    set_home:
      StrCpy $home "$9$option_home_usb"
      Goto set_usb
      
    is_emacs_portable:
      IfFileExists "$9PortableApps\EmacsPortable.App\EmacsPortableApp.exe" set_usb
      IfFileExists "$9Apps\EmacsPortable.App\EmacsPortableApp.exe" set_usb
      IfFileExists "$9EmacsPortable.App\EmacsPortableApp.exe" set_usb
      IfFileExists "$9PortableApps" set_usb
      IfFileExists "$9Apps" set_usb
      Goto findcygwin
      
    set_usb:
      Goto findcygwin
      
    findcygwin:
      IfFileExists "$9mingw\bin\gdb.exe" 0 +3
      StrCpy "$msys" "$9mingw"
      System::Call 'Kernel32::SetEnvironmentVariableA(t, t) i("MSYS", "$msys").r0'
      IfFileExists "$9cygwin" 0 spa
      IfFileExists "$9cygwin\bin\mount.exe" 0 spa
      StrCpy "$cygwin" "$9cygwin"
      System::Call 'Kernel32::SetEnvironmentVariableA(t, t) i("CYGWIN_DIR", "$cygwin").r0'
      StrCpy "$mount" "$9cygwin\bin\mount.exe"
      
    spa:    
      Push $0
      
  FunctionEnd
  
#+END_SRC

** Get Home Path
#+BEGIN_SRC nsis
  Function GetHomePath
    Var /GLOBAL OHOME
    System::Call 'Kernel32::GetEnvironmentVariable(t, t, i) i("HOME", .r0, ${NSIS_MAX_STRLEN}).r1'
    StrCpy $OHOME $0            #
    
    ${ReadINIStrWithDefault} $option_home $epdata\ini\EmacsPortableApp.ini "EmacsPortableApp" "Home" "EXEDIR:\Data\Home"
    ${StrSlash} "$option_home" "/"  
    StrCpy $option_home_usb ""
    StrCpy $option_home $R0
    
    
    ## Make sure doesn't end with /
    StrCpy $R0 $option_home "" -1
    StrCmp $R0 "\" 0 +2
    StrCpy $option_home $option_home -1
    
    StrCpy $R0 $option_home 5
    StrCmp "$R0" "USB:\" home_usb home_exe
    
    home_usb:
      StrCpy $option_home_usb $option_home "" 5
      Goto end
    home_exe:
      StrCpy $R0 $option_home 8
      StrCmp "$R0" "EXEDIR:\" 0 home_exists
      StrCpy $option_home $option_home "" 8
      StrCpy "$R0" $option_home 4
      ${If} $R0 == "Data"
        StrCpy $option_home $option_home "" 4
        GetFullPathName /SHORT $home "$epdata\$option_home"
      ${Else}
        GetFullPathName /SHORT $home "$EXEDIR\..\..\$option_home"
      ${EndIf}
      Goto end
    home_exists:
      IfFileExists "$R0" 0 leave_home
      StrCpy $home $R0
      Goto end
    leave_home:
      StrCpy $home $OHOME
    end:
      ${GetDrives} "FDD+HDD" "GetDriveVars"
      ${If} $home == ""
        StrCpy $R0 $EXEDIR 3
        StrCpy $home "$R0$option_home_usb"
      ${EndIf}
      System::Call 'Kernel32::SetEnvironmentVariableA(t, t) i("HOME", "$home").r0'
      System::Call 'Kernel32::SetEnvironmentVariableA(t, t) i("OHOME", "$OHOME").r0'
      System::Call 'Kernel32::SetEnvironmentVariableA(t, t) i("PWD", "$home").r0'
  FunctionEnd
  
#+END_SRC

** Add To Environment
#+BEGIN_SRC nsis
  !macro AddToEnvironment
    SetOutPath "$epdata\AppData"
    System::Call 'Kernel32::SetEnvironmentVariableA(t, t) i("AppData", "$epdata\AppData").r0'
    SetOutPath "$epdata\AllUsers"
    System::Call 'Kernel32::SetEnvironmentVariableA(t, t) i("ALLUSERSPROFILE", "$epdata\AllUsers").r0'
    SetOutPath "$epdata\UserProfile"
    System::Call 'Kernel32::SetEnvironmentVariableA(t, t) i("ALLUSERSPROFILE", "$epdata\AllUsers").r0'
    ;; Add User-name to the USER variable
    System::Call "advapi32::GetUserName(t .r0, *i ${NSIS_MAX_STRLEN} r1) i.r2"
    System::Call 'Kernel32::SetEnvironmentVariableA(t, t) i("USER", "$0").r0'
    System::Call 'Kernel32::SetEnvironmentVariableA(t, t) i("EMACSVER", "$option_version").r0'
    
    ;; Add My Documents to MYDOC variable
    ReadRegStr $0 HKCU "SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders" \
        Personal
    System::Call 'Kernel32::SetEnvironmentVariableA(t, t) i("MYDOC", "$0").r0'
    ;; Add Server file to environment
    System::Call 'Kernel32::SetEnvironmentVariableA(t, t) i("EMACS_SERVER_FILE", "$server_file").r0'
    ;; Add environment sections before loading.
    IfFileExists "$epdata\ini\Environment.ini" 0 done_1
    EnumINI::Section "$epdata\ini\Environment.ini" "Environment"
    Pop $R0
    StrCmp $R0 "error" done_1
    loop_1:
      IntCmp $R0 "0" done_1 done_1 0
      Pop $R1
      ReadINIStr $R2 "$epdata\ini\Environment.ini" "Environment" "$R1"
      System::Call 'Kernel32::SetEnvironmentVariableA(t, t) i("$R1", "$R2").r0'
      IntOp $R0 $R0 - 1
      Goto loop_1
    done_1:
      
      IfFileExists "$epdata\start\shared\Environment.ini" 0 done_2
      
      EnumINI::Section "$epdata\start\shared\Environment.ini" "Environment"
      Pop $R0
      StrCmp $R0 "error" done_1
    loop_2:
      IntCmp $R0 "0" done_2 done_2 0
      Pop $R1
      ReadINIStr $R2 "$epdata\start\shared\Environment.ini" "Environment" "$R1"
      System::Call 'Kernel32::SetEnvironmentVariableA(t, t) i("$R1", "$R2").r0'
      IntOp $R0 $R0 - 1
      Goto loop_2
    done_2:
  !macroend
  !define AddToEnvironment "!insertmacro AddToEnvironment"
  
#+END_SRC

** Setup Emacs Specific Environment Variables
#+BEGIN_SRC nsis
  Function SetupDirs
    ${If} ${FileExists} "$EXEDIR\..\emacs-$option_version\etc"
      System::Call 'Kernel32::SetEnvironmentVariableA(t, t) i("EMACSDATA", "$EXEDIR\..\emacs-$option_version\etc").r0'
      System::Call 'Kernel32::SetEnvironmentVariableA(t, t) i("EMACSDOC", "$EXEDIR\..\emacs-$option_version\etc").r0'
      ${If} ${FileExists} "$EXEDIR\..\emacs-$option_version\leim"
        System::Call 'Kernel32::SetEnvironmentVariableA(t, t) i("EMACSLOADPATH", "$EXEDIR\..\site-lisp;$EXEDIR\..\emacs-$option_version\lisp;$EXEDIR\..\emacs-$option_version\leim").r0'
      ${Else}
        System::Call 'Kernel32::SetEnvironmentVariableA(t, t) i("EMACSLOADPATH", "$EXEDIR\..\site-lisp;$EXEDIR\..\emacs-$option_version\lisp").r0'
      ${EndIf}
   System::Call 'Kernel32::SetEnvironmentVariableA(t, t) i("INFOPATH", "$EXEDIR\..\emacs-$option_version\info").r0'
      System::Call 'Kernel32::SetEnvironmentVariableA(t, t) i("EPOTHER","$EXEDIR\..\..\Other\").r0'
    ${ElseIf} ${FileExists} "$EXEDIR\..\emacs-$option_version\share\emacs\$option_version\etc"
      System::Call 'Kernel32::SetEnvironmentVariableA(t, t) i("EMACSDATA", "$EXEDIR\..\emacs-$option_version\share\emacs\$option_version\etc").r0'
      System::Call 'Kernel32::SetEnvironmentVariableA(t, t) i("EMACSDOC", "$EXEDIR\..\emacs-$option_version\share\emacs\$option_version\etc").r0'
      System::Call 'Kernel32::SetEnvironmentVariableA(t, t) i("EMACSLOADPATH", "$EXEDIR\..\site-lisp;$EXEDIR\..\emacs-$option_version\share\emacs\$option_version\lisp").r0'
      System::Call 'Kernel32::SetEnvironmentVariableA(t, t) i("INFOPATH", "$EXEDIR\..\emacs-$option_version\share\info").r0'
      System::Call 'Kernel32::SetEnvironmentVariableA(t, t) i("EPOTHER","$EXEDIR\..\..\Other\").r0'
    ${EndIf}
  FunctionEnd
  !define SetupDirs "Call SetupDirs"
#+END_SRC
* Setup Files
** Copy Dlls to the correct position
#+BEGIN_SRC nsis
  !define dllcp `!insertmacro _dllcp`
  !macro _dllcp FILENAME FILETO
    DetailPrint "$EXEDIR\..\${FILENAME} -> $emacs_dir\${FILETO}"
    ${IfNot} ${FileExists} "$emacs_dir\${FILETO}"
      ${If} ${FileExists} "$EXEDIR\..\${FILENAME}"
        CopyFiles /SILENT "$EXEDIR\..\${FILENAME}" "$emacs_dir\${FILETO}"
        ${If} ${FileExists} "$EXEDIR\..\emacs-$option_version\ext-bin.7z"
          SetOutPath "$real_temp\ep"
          ${If} ${FileExists} "$EXEDIR\..\7z\7z.exe"
            nsExec::ExecToLog /OEM "$\"$EXEDIR\..\7z\7z.exe$\" a -mx9 -t7z $EXEDIR\..\emacs-$option_version\ext-bin.7z $R5emacs-$option_version\bin\${FILETO} -ms=off -mmt"
            Push $0
            Exch
            Pop $0
            Pop $0
          ${Else}
            ExecWait "$\"$EXEDIR\..\7z\7zG.exe$\" a -mx9 -t7z $EXEDIR\..\emacs-$option_version\ext-bin.7z $R5emacs-$option_version\bin\${FILETO} -ms=off -mmt"
          ${EndIf}
        ${ElseIf} ${FileExists} "$EXEDIR\..\emacs\ext-bin-$option_version.7z"
          SetOutPath "$real_temp\ep"
          ${If} ${FileExists} "$EXEDIR\..\7z\7z.exe"
            nsExec::ExecToLog /OEM "$\"$EXEDIR\..\7z\7z.exe$\" a -mx9 -t7z $EXEDIR\..\emacs\ext-bin-$option_version.7z $R5emacs-$option_version\bin\${FILETO} -ms=off -mmt"
            Push $0
            Exch
            Pop $0
            Pop $0
          ${Else}
            ExecWait "$\"$EXEDIR\..\7z\7zG.exe$\" a -mx9 -t7z $EXEDIR\..\emacs\ext-bin-$option_version.7z $R5emacs-$option_version\bin\${FILETO} -ms=off -mmt"
          ${EndIf}
        ${EndIf}
      ${EndIf}
    ${EndIf}
  !macroend
  
  Function CpDll
    StrCpy $R5 $real_temp 2
    IfFileExists "$EXEDIR\..\ini\copy.ini" 0 end_copy
    EnumINI::Section "$EXEDIR\..\ini\copy.ini" "copy"
    Pop $R0
    StrCmp $R0 "error" end_copy
    loop:
      IntCmp "$R0" "0" end_copy
      Pop $R1
      DetailPrint "Trying to copy $R1 ($R0)"
      ReadIniStr $R2 "$EXEDIR\..\ini\copy.ini" "copy" "$R1"
      ${dllcp} $R1 $R2
      IntOp $R0 $R0 - 1
      Goto loop
    end_copy:
      ClearErrors
  FunctionEnd
  !define CpDll "Call CpDll"
  
#+END_SRC
** Create Zip-file of emacs
#+BEGIN_SRC nsis
  Function CreateZip
    Push $R0
    Push $R1
    ${ReadINIStrWithDefault} $R0 $epdata\ini\EmacsPortableApp.ini "EmacsPortableApp" "Zip" "0"
    StrCmp "$R0" "0" extract_zip zip_binaries
    extract_zip:
      ${If} ${FileExists} "$EXEDIR\..\emacs-$option_version\bare-bin.7z"
        GetFullPathName /SHORT $R1 "$EXEDIR\..\"
        SetOutPath $R1
        nsExec::ExecToLog /OEM '"$EXEDIR\..\7z\7z.exe" x "$EXEDIR\..\emacs-$option_version\bare-bin.7z" -o$R1 -mmt -y'
        ${If} ${FileExists} "$EXEDIR\..\emacs-$option_version\bin\emacs.exe"
          Delete "$EXEDIR\..\emacs-$option_version\bare-bin.7z"
        ${EndIf}
      ${EndIf}
      ${If} ${FileExists} "$EXEDIR\..\emacs-$option_version\ext-bin.7z"
        GetFullPathName /SHORT $R1 "$EXEDIR\..\"
        SetOutPath $R1
        nsExec::ExecToLog /OEM '"$EXEDIR\..\7z\7z.exe" x "$EXEDIR\..\emacs-$option_version\ext-bin.7z" -o$R1 -mmt -y'
        ${If} ${FileExists} "$EXEDIR\..\emacs-$option_version\bin\emacsclient.exe"
          Delete "$EXEDIR\..\emacs-$option_version\ext-bin.7z"
        ${EndIf}
      ${EndIf}
      ${If} ${FileExists} "$EXEDIR\..\emacs\bare-bin-$option_version.7z"
        GetFullPathName /SHORT $R1 "$EXEDIR\..\"
        SetOutPath $R1
        nsExec::ExecToLog /OEM '"$EXEDIR\..\7z\7z.exe" x "$EXEDIR\..\emacs\bare-bin-$option_version.7z" -o$R1 -mmt -y'
        ${If} ${FileExists} $EXEDIR\..\emacs-$option_version\libexec\emacs\$option_version
          Delete "$EXEDIR\..\emacs\bare-bin-$option_version.7z"
        ${EndIf}
      ${EndIf}
      ${If} ${FileExists} "$EXEDIR\..\emacs\ext-bin-$option_version.7z"
        GetFullPathName /SHORT $R1 "$EXEDIR\..\"
        SetOutPath $R1
        nsExec::ExecToLog /OEM '"$EXEDIR\..\7z\7z.exe" x "$EXEDIR\..\emacs\ext-bin-$option_version.7z" -o$R1 -mmt -y'
        ${If} ${FileExists} $EXEDIR\..\emacs-$option_version\libexec\emacs\$option_version
          Delete "$EXEDIR\..\emacs\ext-bin-$option_version.7z"
        ${EndIf}
      ${EndIf}
      Goto end
    zip_binaries:
      IfFileExists "$EXEDIR\..\emacs-$option_version\ext-bin.7z" end
      IfFileExists "$EXEDIR\..\emacs\ext-bin-$option_version.7z" end
      Pop $R1
      Pop $R0
      
      StrCmp $R0 "" end found_7z
    found_7z:
      ## Now zip
      DetailPrint "Zipping binary files"
      ${If} ${FileExists} "$EXEDIR\..\emacs-$option_version\bin\emacs.exe"
        SetOutPath "$EXEDIR\.."
        ExecWait '"$EXEDIR\..\7z\7zG.exe" a -mx9 -t7z emacs-$option_version\bare-bin.7z emacs-$option_version\bin\emacs.exe emacs-$option_version\etc\DOC-X -mmt -ms=on -m0=PPMd'
        ExecWait '"$EXEDIR\..\7z\7zG.exe"  a -mx9 -t7z emacs-$option_version\ext-bin.7z \
            emacs-$option_version\bin\emacsclient.exe \
            emacs-$option_version\bin\runemacs.exe \
            emacs-$option_version\bin\cmd*.exe \
            emacs-$option_version\bin\hex*.exe \
            emacs-$option_version\bin\ebr*.exe \
            emacs-$option_version\bin\move*.exe \
            emacs-$option_version\bin\*tags*.exe \
            emacs-$option_version\bin\dd*.exe \
            emacs-$option_version\bin\dd*.exe -mmt -m0=PPMd -ms=off'
        ## Should remove but after we test 
        RmDir /R "$EXEDIR\..\emacs-$option_version\bin"
      ${Else} 
        SetOutPath $TEMP\epz\emacs-$option_version\bin
        SetOutPath $TEMP\epz\emacs-$option_version\share\emacs\$option_version\etc
        SetOutPath $TEMP\epz\emacs-$option_version\libexec\emacs\$option_version\i686-pc-mingw32
        
        CopyFiles /SILENT $EXEDIR\..\emacs-$option_version\bin\emacs-$option_version.exe $TEMP\epz\emacs-$option_version\emacs.exe
        CopyFiles /SILENT $EXEDIR\..\emacs-$option_version\share\emacs\$option_version\etc\DOC* $TEMP\epz\emacs-$option_version\share\emacs\$option_version\etc
        
        CopyFiles /SILENT $EXEDIR\..\emacs-$option_version\bin\emacsclient.exe $TEMP\epz\emacs-$option_version\emacsclient.exe
        CopyFiles /SILENT $EXEDIR\..\emacs-$option_version\bin\runemacs.exe $TEMP\epz\emacs-$option_version\runemacs.exe
        CopyFiles /SILENT $EXEDIR\..\emacs-$option_version\bin\runemacs.exe $TEMP\epz\emacs-$option_version\runemacs.exe
        CopyFiles /SILENT $EXEDIR\..\emacs-$option_version\libexec\emacs\$option_version\i686-pc-mingw32\* $TEMP\epz\emacs-$option_version\libexec\emacs\$option_version\i686-pc-mingw32
        SetOutPath $TEMP\epz
        ExecWait '"$EXEDIR\..\7z\7zG.exe" a -mx9 -t7z bare-bin-$option_version.7z emacs-$option_version\bin\emacs.exe emacs-$option_version\etc\DOC-X -mmt -ms=on -m0=PPMd'
        ExecWait '"$EXEDIR\..\7z\7zG.exe"  a -mx9 -t7z ext-bin-$option_version.7z \
            emacs-$option_version\bin\emacsclient.exe \
            emacs-$option_version\bin\runemacs.exe \
            emacs-$option_version\libexec\emacs\$option_version\i686-pc-mingw32\cmd*.exe \
            emacs-$option_version\libexec\emacs\$option_version\i686-pc-mingw32\hex*.exe \
            emacs-$option_version\libexec\emacs\$option_version\i686-pc-mingw32\ebr*.exe \
            emacs-$option_version\libexec\emacs\$option_version\i686-pc-mingw32\move*.exe \
            emacs-$option_version\libexec\emacs\$option_version\i686-pc-mingw32\*tags*.exe \
            emacs-$option_version\libexec\emacs\$option_version\i686-pc-mingw32\dd*.exe \
            emacs-$option_version\libexec\emacs\$option_version\i686-pc-mingw32\dd*.exe -mmt -m0=PPMd -ms=off'
        CopyFiles /SILENT $TEMP\epz\bare-bin-$option_version.7z $EXEDIR\..\emacs\bare-bin-$option_version.7z
        CopyFiles /SILENT $TEMP\epz\ext-bin-$option_version.7z $EXEDIR\..\emacs\ext-bin-$option_version.7z
        RmDir /R "$EXEDIR\..\emacs-$option_version\libexec\emacs\$option_version"
        Delete "$EXEDIR\..\emacs-$option_version\emacs-$option_version.exe"
      ${EndIf}
    end:
      ClearErrors
      Pop $R0
  FunctionEnd
  
#+END_SRC
** Setup Emacs Contents Directory for Mac OS X
#+BEGIN_SRC nsis
  !include "emacsCall.nsh"
  Function SetupContents
    IfFileExists "$EXEDIR\..\..\Contents\Info.plist" end 0
    Call AddEmacsPath
    StrCmp $found_emacs "" end 0
    StrCpy $R0 "$EXEDIR\..\MacOS\build-plist.el"
    ${StrSlash} "$R0" "/"
    ${ExecHide} "$found_emacs\emacs.exe -Q --batch -l $R0 -f build-app-info" "$found_emacs" $R1
    end:
      ClearErrors
  FunctionEnd
  
#+END_SRC
* Setup EmacsServer Directories
#+BEGIN_SRC nsis
  Function SetupServer
    StrCmp "" $option_dos setupdos setupwin
    ## Now Setup server
    setupwin:
      IfFileExists "$real_temp\ep\EmacsPortable.App-Server-$option_version$epstart"  0 +2
      RmDir /r "$real_temp\ep\EmacsPortable.App-Server-$option_version$epstart"
      CreateDirectory "$real_temp\ep\EmacsPortable.App-Server-$option_version$epstart"
      StrCpy $server_file "$real_temp\ep\EmacsPortable.App-Server-$option_version$epstart\server"
      Goto end
    setupdos:
      IfFileExists "$real_temp\ep\epd-$option_version$epstart"  0 +2
      RmDir /r "$real_temp\ep\epd-$option_version$epstart"
      CreateDirectory "$real_temp\ep\epd-$option_version$epstart"
      StrCpy $server_file "$real_temp\ep\epd-$option_version$epstart\server"
    end:
      ClearErrors
  FunctionEnd
  
#+END_SRC

* Calling Commands
** Configure Emacs Command
#+BEGIN_SRC nsis
  Function EmacsCmd
    StrCpy $found_gdb ""
    ${If} $option_debug == ""
      StrCpy $cmd "$emacs_dir\$emacs_exe"
      StrCpy $cmd_args "$option_debug$option_dos$option_q $cmdLineParams"
    ${Else}
      ${If} ${FileExists} "$msys\bin\gdb.exe"
        System::Call 'Kernel32::SetEnvironmentVariableA(t, t) i("MSYS", "$msys").r0'
        StrCpy $cmd "$msys\bin\gdb.exe"
      ${ElseIf} ${FileExists} "$usbs\PortableApps\CommonFiles\MinGW\bin\gdb.exe"
        System::Call 'Kernel32::SetEnvironmentVariableA(t, t) i("MSYS", "$usbs\PortableApps\CommonFiles\MinGW").r0'
        StrCpy $cmd "$usbs\PortableApps\CommonFiles\MinGW\bin\gdb.exe"
      ${ElseIf} ${FileExists} "$usbs\Apps\CommonFiles\MinGW\bin\gdb.exe"
        System::Call 'Kernel32::SetEnvironmentVariableA(t, t) i("MSYS", "$usbs\Apps\CommonFiles\MinGW").r0'
        StrCpy $cmd "$usbs\Apps\CommonFiles\MinGW\bin\gdb.exe"
      ${ElseIf} ${FileExists} "$usbs\LiberKey\MyApps\CommonFiles\MinGW\bin\gdb.exe"
        System::Call 'Kernel32::SetEnvironmentVariableA(t, t) i("MSYS", "$usbs\LiberKey\MyApps\CommonFiles\MinGW").r0'
        StrCpy $cmd "$usbs\LiberKey\MyApps\CommonFiles\MinGW\bin\gdb.exe"
      ${ElseIf} ${FileExists} "$cygwin\bin\gdb.exe"
        StrCpy $cmd "$cygwin\bin\gdb.exe"
      ${Else}
        StrCpy $cmd "$emacs_dir\$emacs_exe"
        StrCpy $cmd_args "$option_debug$option_dos$option_q $cmdLineParams"
      ${EndIf}
      ${If} $cmd != "$emacs_dir\$emacs_exe"
        StrCpy $cmd_args '"$emacs_dir\$emacs_exe"'
        ${If} ${FileExists} "$EXEDIR\..\gdbinit"
        ${AndIf} $cmd  != "$cygwin\bin\gdb.exe"
          StrCpy $cmd_args '$cmd_args --eval-command "source $EXEDIR\..\gdbinit"'
        ${EndIf}
        StrCpy $cmd_args '$cmd_args --eval-command "Run '
        StrCpy $found_gdb "1"
      ${EndIf}
    ${EndIf}
    System::Call 'Kernel32::SetEnvironmentVariableA(t, t) i("EPEXE", "$EXEDIR\..\..\EmacsPortableApp.exe").r0'
    ClearErrors
        Goto skip_font
    IfFileExists "$EXEDIR\..\ini\fonts.ini" 0 skip_font
    ReadINIStr $R0 $EXEDIR\..\ini\fonts.ini "fonts1" "$option_font"
    IfErrors skip_font
    ReadINIStr $R1 $EXEDIR\..\ini\fonts.ini "fonts2" "$option_font"
    IfErrors 0 +2
    StrCpy "$R1" "-*-*-*-c-*-iso8859-1"
    ClearErrors
    IntOp $R3 $option_font_size * 96
    IntOp $R3 $R3 / 72
    ##WriteRegStr HKCU "SOFTWARE\GNU\Emacs" "Emacs.Font"  "$R0$R3$R1"
    System::Call 'Kernel32::SetEnvironmentVariableA(t, t) i("EPFONT", "$R0$R3$R1").r0'
    ${If} $found_gdb == ""
      StrCpy $cmd_args '$cmd_args --font "$R0$R3$R1"'
    ${Else}
      StrCpy $cmd_args '$cmd_args --font $R0$R3$R1'
    ${EndIf}
    skip_font:
      
      StrCmp "$option_scrollbar" "1" 0 +2
      StrCpy $cmd_args "$cmd_args -vb"
      
      StrCmp "" "$option_foreground" +2 0
      StrCpy $cmd_args "$cmd_args -fg $option_foreground"
      
      StrCmp "" "$option_background" +2 0
      StrCpy $cmd_args "$cmd_args -bg $option_background"
      
      Strcmp "" "$option_geometry" +2 0
      StrCpy $cmd_args "$cmd_args -g $option_geometry"
      
      StrCmp $option_maximized "1" 0 +2
      StrCpy $cmd_args "$cmd_args -mm"
      
      StrCmp $option_fullwidth "1" 0 +2
      StrCpy $cmd_args "$cmd_args -fw"
      
      StrCmp $option_fullheight "1" 0 +2
      StrCpy $cmd_args "$cmd_args -fh"
      
      StrCmp $found_gdb "" +2 0
      StrCpy $cmd_args `$cmd_args"`
  
      StrCpy $emacs '"$cmd" $cmd_args'
  FunctionEnd
  !define EmacsCmd "Call EmacsCmd"  
  
#+END_SRC

** Setup things necessary to call Emacs
#+BEGIN_SRC nsis
  !macro emacs_setup
    DetailPrint "Setup Mac Contents Folder and AppInfo"
    Call SetupContents
    DetailPrint "Setup Home path"
    Call GetHomePath
    DetailPrint "Zip Binaries"
    Call CreateZip
    DetailPrint "Extract Binaries"
    Call ExtractZip
    ${If} ${FileExists} "$EXEDIR\..\emacs-$option_version\bin"
    ${ElseIf} ${FileExists} "$real_temp\ep\emacs-$option_version\bin"
      StrCpy "$emacs_dir" "$real_temp\ep\emacs-$option_version\bin"
    ${EndIf}
    
    
    DetailPrint "Remove Stale Emacs Server, if it exists"
    Call SetupServer
    DetailPrint "Setup Emacs EXE"
    ${SetupEmacsExe}
    DetailPrint "Setup Necessary DLLs"
    ${CpDll}
    DetailPrint "Add to Environment Variables"
    ${AddToEnvironment}
    DetailPrint "Setup where emacs should run from"
    ${SetupDirs}
    DetailPrint "Setup Path and Environment"
    ${SetEnv}
    ${If} ${FileExists} "$real_temp\ep\emacs-$option_version\bin\libexec\emacs\$option_version\i686-pc-mingw32"
      GetFullPathName /SHORT $R0 "$real_temp\ep\emacs-$option_version\bin\libexec\emacs\$option_version\i686-pc-mingw32"
      DetailPrint "Path Add: $R0"
      System::Call 'Kernel32::GetEnvironmentVariable(t , t, i) i("PATH", .r3, ${NSIS_MAX_STRLEN}).r2'
      System::Call 'Kernel32::SetEnvironmentVariableA(t, t) i("PATH", "$R0;$3").r2'
    ${EndIf}
    ${If} ${FileExists} "$real_temp\ep\emacs-$option_version\bin"
      GetFullPathName /SHORT $R0 "$real_temp\ep\emacs-$option_version\bin"
      DetailPrint "Path Add: $R0"
      System::Call 'Kernel32::GetEnvironmentVariable(t , t, i) i("PATH", .r3, ${NSIS_MAX_STRLEN}).r2'
      System::Call 'Kernel32::SetEnvironmentVariableA(t, t) i("PATH", "$R0;$3").r2'
    ${EndIf}
    DetailPrint "Setup emacs options"
    ${EmacsCmd}
    WriteIniStr "$real_temp\ep\ep.ini" "EmacsPortableApp" "EXEDIR\..\.." "$EXEDIR\..\.."
    SetOutPath "$EXEDIR\..\eps"
    EnumINI::Section "$EXEDIR\..\ini\plugins.ini" "plugins"
    Pop $R0 
    StrCmp $R0 "error" done_plugins
    loop_plugins:
      IntCmp $R0 "0" done_plugins done_plugins 0
      Pop $R1
      ReadINIStr $R2 "$EXEDIR\..\ini\plugins.ini" "plugins" "$R1"
      IfFileExists "$EXEDIR\$R1" 0 +6
      IfFileExists "$EXEDIR\rm-$R1" 0 +3
      DetailPrint "$R2 has already been installed"
      Goto +9
      DetailPrint "Setup $R2"
      ## Wait for the Plug-in to finish before launching emacs?
      ReadINIStr $R3 "$EXEDIR\..\ini\plugins.ini" "wait.for" "$R1"
      IfErrors +4
      StrCmp "$R3" "1" 0 +3
      ExecWait "$EXEDIR\$R1"
      Goto +2
      Exec "$EXEDIR\$R1"
      ClearErrors
      IntOp $R0 $R0 - 1
      Goto loop_plugins
    done_plugins:
    !macroend
    !define emacs_setup "!insertmacro emacs_setup"
#+END_SRC

** Setup things necessary to call EmacsClient
#+BEGIN_SRC nsis
  !macro emacsclient_setup
    ${SetupDirs}
    StrCpy $cmd "$emacs_dir\$emacs_client_exe"
    StrCmp "" $option_colorsync 0 colorsync
    StrCmp "" $option_dos setupwin_client setupdos_client
    setupdos_client:
      ${If} $cmdLineParams == ""
        StrCpy $cmd_args '-d 0 --server-file "$real_temp\ep\epd-$option_version$epstart\server" $cmdLineParams'
      ${Else}
        StrCpy $cmd_args '-t -d 0 --server-file "$real_temp\ep\epd-$option_version$epstart\server"'
      ${EndIf}
      goto end_client
    setupwin_client:
      ## Only open a new window when emacs isn't visible, or when
      ## clicking on EmacsPortableApp
      ${If} $cmdLineParams == ""
        ReadIniStr $R0 "$epdata\ini\EmacsPortableApp.ini" "EmacsPortableApp" "NewFrame"
        ${If} $R0 == "1"
          ${If} ${FileExists} "$real_temp\ep\hidden-$option_version"
            StrCpy $R9 " -c"
          ${Else}
            StrCpy $R9 ""
          ${EndIf}
        ${Else}
          StrCpy $R9 " -c"
        ${EndIf}
      ${Else}
        ${StrRep} $0 $cmdLineParams "--eval " ""
        ${If} $0 == $cmdLineParams
          ${StrRep} $0 $cmdLineParams "-e " ""
          ${If} $0 == $cmdLineParams
            ${StrRep} $0 $cmdLineParams "org-protocol:/" ""
            ${If} $0 == $cmdLineParams
              StrCpy $R9 " -c"
            ${Else}
              StrCpy $R9 "" ## org protocol, don't add -c.
            ${EndIf}
          ${Else}
            ## An eval, don't use -c.
            StrCpy $R9 ""
          ${EndIf}
        ${Else}
          ## An eval, don't use -c.
          StrCpy $R9 ""
        ${EndIf}
      ${EndIf}
      StrCpy $cmd_args `$R9 -n --server-file "$real_temp\ep\EmacsPortable.App-Server-$option_version$epstart\server" $cmdLineParams`
      StrCmp "$cmdLineParams" "" +5
      Goto end_client
    colorsync:
      StrCpy $cmd_args `--server-file "$real_temp\ep\EmacsPortable.App-Server-$option_version$epstart\server" --eval "(if (fboundp 'emacs-portable-sync-display) (emacs-portable-sync-display))"`
    end_client:
      StrCpy $emacs "$cmd $cmd_args"
      ClearErrors
  !macroend
  !define emacsclient_setup "!insertmacro emacsclient_setup"
  
#+END_SRC

* Callback Functions
** Initialization
#+BEGIN_SRC nsis
  Function .onInit 
    ${GetParameters} $cmdLineParams    

    # Get local installation.
    ReadRegStr $0 HKCU "Software\EmacsPortable.App" ""
    ClearErrors
    ${IfNot} $0 == ""
      GetFullPathName $0 $0
      GetFullPathName $1 $EXEDIR\..\..
      ${IfNot} $1 == $0
        # Call From locally installed EmacsPortable.App
        GetFullPathName $1 "$EXEDIR\..\..\Data"
        ClearErrors
        System::Call 'Kernel32::SetEnvironmentVariableA(t, t) i("EPDATA", "$1").r1'
        Exec '"$0\EmacsPortableApp.exe" $cmdLineParams'
        Abort
      ${EndIf}
    ${EndIf}
    
    ReadEnvStr $epdata "EPDATA"
    ClearErrors
    
    ${If} $epdata == ""
      StrCpy $epdata "$EXEDIR\..\..\Data"
    ${EndIf}  
    ClearErrors
  FunctionEnd
  
#+END_SRC

* Main Script
#+BEGIN_SRC nsis
  Section "Main" sec_mainN
    StrCpy "$INSTDIR" "$EXEDIR\..\.."
    DetailPrint "Checking Temporary directory..."
    StrCpy $R0 ""
    StrCpy $R2 ""
    StrCpy $R3 $TEMP
    ${Do}
      DetailPrint "Testing Temp $TEMP"
      ${If} ${FileExists} $R3\ep
        StrCpy $R0 "1"
      ${Else}
        GetFullPathName /SHORT $R3 $R3\..
        StrLen $R1 $R3
        StrCpy $R2 "1"
        ${If} $R1 < 4
          StrCpy $R0 "1"
          StrCpy $R2 ""
        ${EndIf}
      ${EndIf}
    ${LoopUntil} $R0 == "1"
    
    ${If} $R2 == "1"
      StrCpy $real_temp "$R3"
      System::Call 'Kernel32::SetEnvironmentVariableA(t, t) i("TEMP", "$real_temp").r0'
      DetailPrint "Reset Temporary Directory to $real_temp"
    ${Else}
      StrCpy $real_temp "$TEMP"
      DetailPrint "Kept Directory $real_temp"
    ${EndIf}
    
    StrLen $R2 $EXEFILE
    ${IfNot} ${FileExists} "$EXEDIR\..\7z\7zG.exe"
      ExecWait '"$EXEDIR\..\..\EmacsOptions.exe" /7z'
    ${EndIf}
    ${If} $R2  == 12
      Exec "$EXEDIR\..\..\EmacsPortableApp.exe"
    ${ElseIfNot} ${FileExists} "$EXEDIR\..\7z\7zG.exe"
      MessageBox MB_ICONEXCLAMATION|MB_OK "Cannot find 7zip.  Cannot run this program..."
    ${Else}
      ${GetWindowsVersion} $R0
      ${If} $R0 == "7"
        ;; Should Allow running hidden processes?
        System::Call 'shell32::SetCurrentProcessExplicitAppUserModelID(w "GNU.Emacs")'
      ${EndIf}
      DetailPrint "Get Command Options"
      ${GetCmdOptions}
      DetailPrint "Setup Data"
      ${setupData}
      SetOutPath "$real_temp\ep"
      StrCpy $EPEXE $EXEDIR\..\..
      StrCmp $option_updateproxy "" 0 sync_proxy
      ${If} ${FileExists} "$EXEDIR\..\emacs-$option_version\bin"
        StrCpy "$emacs_dir" "$EXEDIR\..\emacs-$option_version\bin"
      ${Else} 
        StrCpy "$emacs_dir" "$EXEDIR\..\emacs\bin"
      ${EndIf}
      IfFileExists "$real_temp\ep\emacs-$option_version\bin" 0 +2
      StrCpy "$emacs_dir" "$real_temp\ep\emacs-$option_version\bin"
      FindProcDLL::FindProc "$emacs_exe"
      StrCmp $R0 "1" start_emacsclient start_emacs
      sync_proxy:
        FindFirst $0 $1 "$EXEDIR\..\emacs-*"
      loop_proxy:
        HideWindow
        StrCmp $1 "" done_proxy
        ;; FIXME etc
        ${If} ${FileExists} $EXEDIR\..\$1\etc
          DetailPrint "Checking for running $1.exe"
          FindProcDLL::FindProc "$1.exe"
          StrCmp "$R0" "1" 0 loop_next
          DetailPrint "$1 is running"
          StrCpy $2 $1 "" 6
          IfFileExists "$EXEDIR\..\emacs-$2\bin\emacsclient.exe" 0 +3
          StrCpy $3 "$EXEDIR\..\emacs-$2\bin\emacsclient.exe"
          Goto +3
          IfFileExists "$real_temp\ep\emacs-$2\bin\emacsclient.exe" 0 loop_next
          StrCpy $3 "$real_temp\ep\emacs-$2\bin\emacsclient.exe"
          SetOutPath $home
          Exec '"$3" --server-file "$real_temp\ep\EmacsPortable.App-Server-$option_version$epstart\server" --eval "(if (fboundp $\'refresh-proxy) (refresh-proxy))"'
        ${EndIf}
      loop_next:
        FindNext $0 $1
        Goto loop_proxy
      done_proxy:
        ;; FIXME look for other versions...
        Goto end
      start_emacs:
        DetailPrint "Start Emacs"
        StrCmp $option_colorsync "" 0 cant_sync
        ${emacs_setup}
        WriteIniStr "$real_temp\ep\ep-reg.ini" "run" "$option_version$epstart" "1"
        StrCmp "" $option_batch +2 0
        StrCmp "" $option_silent start_emacs_dos start_emacs_regular
        StrCmp "" $option_dos 0 start_emacs_dos
        StrCmp "" $found_gdb start_emacs_regular start_emacs_gdb
        
      start_emacs_gdb:
        DetailPrint "Start Emacs with Gdb"
        Push $real_temp
        System::Call 'Kernel32::SetEnvironmentVariableA(t, t) i("TEMP", "$real_temp\ep").r0'
        ${Execute} '"$cmd" $cmd_args' "$home" $R1
        Pop $R0
        Goto loop
        
      start_emacs_regular:
        DetailPrint "Regular emacs startup"
        ${If} $option_help == "1"
          SetOutPath "$real_temp\ep"
          ${ExecHide} '"$cmd" $cmd_args > "$real_temp\ep\emacs-help.txt"' '$home' $R1
          ${If} $R1 == "0"
            SetOutPath $home
            ${Execute} '"$cmd" $cmd_args > "$real_temp\ep\emacs-help.txt"' '$home' $R1
          ${EndIf}
          ClearErrors
          FileOpen $0 "$real_temp\ep\emacs-help.txt" r
          ${DoUntil} ${Errors}
            FileRead $0 $1
            ${If} $R2 == ""
              StrCpy $R2 "$R2$\n$1"
            ${Else}
              StrCpy $R2 "$R2$\n$1"
            ${EndIf}
          ${Loop}
          FileClose $0
          Delete "$real_temp\ep\emacs-help.txt"
          ClearErrors
          MessageBox MB_OK|MB_ICONQUESTION "$R2"
        ${ElseIf} $option_cmd == "1"
          System::Call 'Kernel32::SetEnvironmentVariableA(t, t) i("TEMP", "$real_temp\ep").r0'
          Exec "cmd"
          Goto loop
        ${Else}
          Push $real_temp
          System::Call 'Kernel32::SetEnvironmentVariableA(t, t) i("TEMP", "$real_temp\ep").r0'
          ##${StrRep} "$emacs" "$emacs" '"' '""'
          ${ExecHide} '"$cmd" $cmd_args' "$home" $R1
          ${If} $R1 == "0"
            ${Execute} '"$cmd" $cmd_args' '$home' $R1
          ${EndIf}
          Pop $R0
          System::Call 'Kernel32::SetEnvironmentVariableA(t, t) i("TEMP", "$R0\ep").r0'
          Goto loop
        ${EndIf}
      start_emacs_dos:
        DetailPrint "Start Emacs on DOS"
        System::Call 'Kernel32::SetEnvironmentVariableA(t, t) i("TEMP", "$real_temp\ep").r0'
        ${Execute} '"$cmd" $cmd_args' "$home" $R1
        Goto end
      loop:
        #StrCmp "1" $option_daemon 0 found_running_emacs
        #StrCmp "" $option_q 0 found_running_emacs
        StrCpy $cnt 300
        Exec "$EXEDIR\EmacsPortableServer.exe"
      look_for_running_emacs:
        DetailPrint "Look For Running Emacs"
        FindProcDLL::FindProc "emacs-$option_version$epstart.exe"
        StrCmp "$R0" "1" found_running_emacs
        FindProcDLL::FindProc "emacs-$option_version$epstart-dos.exe"
        StrCmp "$R0" "1" found_running_emacs 
        Sleep 1000 # Wait 1 seconds for emacs process to start.
        IntOp $cnt $cnt - 1
        IntCmp $cnt $cnt 0 end end 
        Goto look_for_running_emacs
      found_running_emacs:
        System::Call 'Kernel32::SetEnvironmentVariableA(t, t) i("TEMP", "$R0").r0'
        IfFileExists "$real_temp\ep\ep-rm.exe" end 0
        writeUninstaller "$real_temp\ep\ep-rm.exe"
        Exec "$real_temp\ep\ep-rm.exe"
        System::Call 'Kernel32::SetEnvironmentVariableA(t, t) i("TEMP", "$R0\ep").r0'
        Goto end
      start_emacsclient:
        DetailPrint "Run EmacsClient"
        StrCmp $option_debug "" +2 
        StrCmp $option_debug_from_ini "" no_debug
        StrCmp $option_q "" 0 start_emacs
        ${emacsclient_setup}
        ${If} $option_help == "1"
          DetailPrint "Help."
          SetOutPath $home
          ${ExecHide} '"$cmd" $cmd_args > "$real_temp\ep\emacs-help.txt"' "$home" $R1
          ClearErrors
          FileOpen $0 "$real_temp\ep\emacs-help.txt" r
          ${DoUntil} ${Errors}
            FileRead $0 $1
            ${If} $R2 == ""
              StrCpy $R2 "$R2$\n$1"
            ${Else}
              StrCpy $R2 "$R2$\n$1"
            ${EndIf}
          ${Loop}
          FileClose $0
          Delete "$real_temp\ep\emacs-help.txt"
          ClearErrors
          MessageBox MB_OK|MB_ICONQUESTION "$R2"
        ${ElseIf} $option_colorsync == ""
          DetailPrint "Colorsync"
          ##${StrRep} $emacs $emacs '"' '""'
          HideWindow
          SetOutPath $home
          DetailPrint '"$cmd" $cmd_args'
          ${ExecHide} '"$cmd" $cmd_args' "$home" $R1
        ${Else}
          DetailPrint "EmacsClient"
          HideWindow
          DetailPrint "$emacs"
          Exec "$emacs"
        ${EndIf}
        Goto end
      no_debug:
        DetailPrint "Setup emacs options"
        ${If} $option_silent == ""
          MessageBox MB_YESNO|MB_ICONEXCLAMATION "EmacsPortable.App already running, Attach gdb?" IDYES attach_gdb IDNO end
        ${Else}
          Goto attach_gdb
        ${EndIf}
      attach_gdb:
        ${SetEnv}
        ${If} ${FileExists} "$msys\bin\gdb.exe"
          System::Call 'Kernel32::SetEnvironmentVariableA(t, t) i("MSYS", "$msys").r0'
              StrCpy $cmd "$msys\bin\gdb.exe"
            ${ElseIf} ${FileExists} "$usbs\PortableApps\CommonFiles\MinGW\bin\gdb.exe"
          System::Call 'Kernel32::SetEnvironmentVariableA(t, t) i("MSYS", "$usbs\PortableApps\CommonFiles\MinGW").r0'
          StrCpy $cmd "$usbs\PortableApps\CommonFiles\MinGW\bin\gdb.exe"
        ${ElseIf} ${FileExists} "$usbs\Apps\CommonFiles\MinGW\bin\gdb.exe"
          System::Call 'Kernel32::SetEnvironmentVariableA(t, t) i("MSYS", "$usbs\Apps\CommonFiles\MinGW").r0'
          StrCpy $cmd "$usbs\Apps\CommonFiles\MinGW\bin\gdb.exe"
        ${ElseIf} ${FileExists} "$usbs\LiberKey\MyApps\CommonFiles\MinGW\bin\gdb.exe"
          System::Call 'Kernel32::SetEnvironmentVariableA(t, t) i("MSYS", "$usbs\LiberKey\MyApps\CommonFiles\MinGW").r0'
          StrCpy $cmd "$usbs\LiberKey\MyApps\CommonFiles\MinGW\bin\gdb.exe"
        ${ElseIf} ${FileExists} "$cygwin\bin\gdb.exe"
          StrCpy $cmd "$cygwin\bin\gdb.exe"
        ${Else}
          MessageBox MB_OK "Cannot find gdb."
          Goto end
        ${EndIf}
        ReadIniStr $0 "$real_temp\ep\ep-pid.ini" "pid" "$emacs_exe"
        ReadIniStr $1 "$real_temp\ep\ep-pid.ini" "exec" "$emacs_exe"
        StrCpy $cmd_args "--pid=$0"
        ${If} ${FileExists} "$EXEDIR\..\gdbinit"
        ${AndIf} $cmd  != "$cygwin\bin\gdb.exe"
          StrCpy $cmd_args '$cmd_args --eval-command "source $EXEDIR\..\gdbinit"'
        ${EndIf}
        StrCpy $cmd_args '$cmd_args --eval-command "Continue" $1'
        ${Execute} '"$cmd" $cmd_args' "$home" $R1
        Pop $R0
        Goto end
      cant_sync:
        HideWindow
        MessageBox MB_OK|MB_ICONSTOP "EmacsPortable.App not running, cannot sync colors and fonts."
        Goto end
      end:
        #
    ${EndIf}
  SectionEnd
  
#+END_SRC
* Uninstall section
This removes registry settings, fonts and other settings.
#+BEGIN_SRC nsis
  Var nver
  Var lastver
  Section "Uninstall" sec_uninstall ; Checked
    ; Description:
    ; Uninstall
    HideWindow
    SetAutoClose true
    ${GetParameters} $cmdLineParams
    ${GetOptions} $cmdLineParams '/SKIP' $R0
    ${IfNot} ${Errors}
      Goto none_left
    ${EndIf}
    ClearErrors
    ;; Wait for EmacsPortableApp.exe to stop
    wait_for_emacsportable_launcher_stop:
      FindProcDLL::FindProc "ep.exe"
      StrCmp "$R0" "1" 0 wait_for_emacsportable_debug_launcher_stop
      Sleep 1000
      Goto wait_for_emacsportable_launcher_stop
    wait_for_emacsportable_debug_launcher_stop:
      FindProcDLL::FindProc "epl.exe"
      StrCmp "$R0" "1" 0 start_notify_plugin
      Sleep 1000
      Goto  wait_for_emacsportable_debug_launcher_stop
    start_notify_plugin:
      
    look_for_running_emacs:
      StrCpy $nver 0
      EnumINI::Section "$real_temp\ep\ep-reg.ini" "run"
      Pop $R2
      StrCmp "$R2" "error" done
    loop_run:
      IntCmp $R2 0 loop_end loop_end 0
      Pop $R1
      FindProcDLL::FindProc "emacs-$R1.exe"
      StrCmp "$R0" "1" wait_for_close skip_cnt
    wait_for_close:
      Sleep 1000
      StrCpy $nver "1"
      FindProcDLL::FindProc "emacs-$R1.exe"
      StrCmp "$R0" "1" wait_for_close skip_cnt
    skip_cnt:
      IntOp $R2 $R2 - 1
      Goto loop_run
    loop_end:
      StrCmp 0 $nver none_left look_for_running_emacs
    none_left:
      ClearErrors
      Delete "$real_temp\ep\ep-rm.exe"
      IfFileExists "$real_temp\ep\ep-reg.ini" 0 done
      Delete "$real_temp\ep\ep-reg.ini"
      Delete "$real_temp\ep\ep-RemoveReg.exe"
    done:
      SetOutPath "$real_temp\ep"
      ReadINIStr $EPEXE "$real_temp\ep\ep.ini" "EmacsPortableApp" "$EXEDIR\..\.."
      IfFileExists "$real_temp\ep\rm-ep-proxy.exe" 0 +2
      ExecWait "$real_temp\ep\rm-ep-proxy.exe"
      EnumINI::Section "$EPEXE\App\ini\plugins.ini" "plugins"
      Pop $R0
      StrCmp $R0 "error" done_plugins
    loop_plugins:
      IntCmp $R0 "0" done_plugins done_plugins 0
      Pop $R1
      ReadINIStr $R2 "$EPEXE\App\ini\plugins.ini" "plugins" "$R1"
      IfFileExists "$real_temp\ep\rm-$R1" 0 +3
      DetailPrint "Remove $R2"
      ExecWait "$real_temp\ep\rm-$R1"
      IntOp $R0 $R0 - 1
      Goto loop_plugins
    done_plugins:
      ClearErrors
      Delete "$real_temp\ep\ep-env.ini"
      Delete "$real_temp\ep\ep-ip2.ini"
      Delete "$real_temp\ep\ep.ini"
      Delete "$real_temp\ep\hidden-*"
      Delete "$real_temp\ep\ep-ip*.txt"
      ReadIniStr $R2 "$EPEXE\Data\ini\EmacsPortableApp.ini" "EmacsPortableApp" "Clean"
      ClearErrors
      ${If} $R2 == "1"
        RmDir /R "$real_temp\ep"
      ${Else}
        FindFirst $0 $1 "$real_temp\ep\*.*"
        ${While} $1 != ""
          StrCpy $2 $1 6
          ${IfNot} $2 == "emacs-"
          ${AndIfNot} $2 == "."
          ${AndIfNot} $2 == ".."
            ${If} ${DirExists} "$real_temp\ep\$1"
              RmDir /R "$real_temp\ep\$1"
            ${Else}
              Delete "$real_temp\ep\$1"
            ${EndIf}
          ${EndIf}
          FindNext $0 $1
        ${EndWhile}
      ${EndIf}
  SectionEnd ; sec_uninstall
  
#+END_SRC
